module.exports = (function() {
var __MODS__ = {};
var __DEFINE__ = function(modId, func, req) { var m = { exports: {}, _tempexports: {} }; __MODS__[modId] = { status: 0, func: func, req: req, m: m }; };
var __REQUIRE__ = function(modId, source) { if(!__MODS__[modId]) return require(source); if(!__MODS__[modId].status) { var m = __MODS__[modId].m; m._exports = m._tempexports; var desp = Object.getOwnPropertyDescriptor(m, "exports"); if (desp && desp.configurable) Object.defineProperty(m, "exports", { set: function (val) { if(typeof val === "object" && val !== m._exports) { m._exports.__proto__ = val.__proto__; Object.keys(val).forEach(function (k) { m._exports[k] = val[k]; }); } m._tempexports = val }, get: function () { return m._tempexports; } }); __MODS__[modId].status = 1; __MODS__[modId].func(__MODS__[modId].req, m, m.exports); } return __MODS__[modId].m.exports; };
var __REQUIRE_WILDCARD__ = function(obj) { if(obj && obj.__esModule) { return obj; } else { var newObj = {}; if(obj != null) { for(var k in obj) { if (Object.prototype.hasOwnProperty.call(obj, k)) newObj[k] = obj[k]; } } newObj.default = obj; return newObj; } };
var __REQUIRE_DEFAULT__ = function(obj) { return obj && obj.__esModule ? obj.default : obj; };
__DEFINE__(1649414428465, function(require, module, exports) {
!function(n,o){"object"==typeof exports&&"object"==typeof module?module.exports=o():"function"==typeof define&&define.amd?define([],o):"object"==typeof exports?exports.paddlejs=o():(n.paddlejs=n.paddlejs||{},n.paddlejs.webglBackend=o())}(this,(function(){return(()=>{var n={646:(n,o,e)=>{e.r(o),e.d(o,{GLHelper:()=>T,glInstance:()=>Tn,ops:()=>xn,webgl_types:()=>t});var t={};e.r(t),e.d(t,{UniformType:()=>c});var r={};e.r(r),e.d(r,{hardSigmoid:()=>k,leakyRelu:()=>R,pow_func:()=>D,prelu:()=>C,relu6:()=>O,scale:()=>S,scaleWidthBias:()=>I,sigmoid:()=>L,sqrt:()=>B,tanh_func:()=>M,transferFromNHWCtoNCHW:()=>A});var i={};function s(){var n;if("undefined"!=typeof window)n=window;else if(void 0!==e.g)n=e.g;else{if("undefined"==typeof self)throw new Error("Could not find a global object");n=self}return n}function a(n,o){var e=s();return e[n]||(e[n]=o),e[n]}e.r(i),e.d(i,{getPixelsFromTexturePos:()=>X,getSamplerCode:()=>H,getTensorPosFromArrayIndex:()=>j,getValueFromTensorPos:()=>U,getValueFromTensorPosPacking:()=>N,moveTexture2PosToReal:()=>G});var u={opRegistry:{ops:{}},backend:"",backendInstance:null};u=a("GLOBALS",u);var l=s();l.ImageBitmap||(l.ImageBitmap=function(){});const f=a("env",new(function(){function n(){this.ENV={}}return n.prototype.set=function(n,o){this.ENV[n]=o},n.prototype.get=function(n){return this.ENV[n]},n}()));var c;!function(n){n.uniform1f="1f",n.uniform1fv="1fv",n.uniform1i="1i",n.uniform1iv="1iv",n.uniform2f="2f",n.uniform2fv="2fv",n.uniform2i="2i",n.uniform2iv="2iv",n.uniform3f="3f",n.uniform3fv="3fv",n.uniform3i="3i",n.uniform3iv="3iv",n.uniform4f="4f",n.uniform4fv="4fv",n.uniform4i="4i",n.uniform4iv="4iv"}(c||(c={}));function _(n){for(var o=n.length,e=function(){for(var n=0,o=0,e=arguments.length;o<e;o++)n+=arguments[o].length;var t=Array(n),r=0;for(o=0;o<e;o++)for(var i=arguments[o],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t}(n),t=[];o>1;)e.splice(0,1),t.push(e.reduce((function(n,o){return n*o}))),o--;return t}function g(n){return n.reduce((function(n,o){return n*o}),1)}function h(n,o){return 0===n.length?"":n.reduce((function(o,e,t){return o+"float("+e+")"+(t===n.length-1?");":",")}),"float "+o+"["+n.length+"] = float[](")}function d(n,o){if(1===n.length)return"float "+o+" = float("+n[0]+");";for(var e=n.length,t="\n        vec"+e+" "+o+" = vec"+e+"(\n    ",r=0;r<e;r++)t+="float("+n[r]+"),";return t.slice(0,-1)+");"}var p,m;!function(n){n[n.VS_SHADER=0]="VS_SHADER",n[n.FS_SHADER=1]="FS_SHADER"}(p||(p={})),function(n){n[n.FLOAT_VEC2=35664]="FLOAT_VEC2",n[n.FLOAT_VEC3=35665]="FLOAT_VEC3",n[n.FLOAT_VEC4=35666]="FLOAT_VEC4",n[n.INT_VEC2=35667]="INT_VEC2",n[n.INT_VEC3=35668]="INT_VEC3",n[n.INT_VEC4=35669]="INT_VEC4",n[n.BOOL=35670]="BOOL",n[n.BOOL_VEC2=35671]="BOOL_VEC2",n[n.BOOL_VEC3=35672]="BOOL_VEC3",n[n.BOOL_VEC4=35673]="BOOL_VEC4",n[n.FLOAT_MAT2=35674]="FLOAT_MAT2",n[n.FLOAT_MAT3=35675]="FLOAT_MAT3",n[n.FLOAT_MAT4=35676]="FLOAT_MAT4",n[n.SAMPLER_2D=35677]="SAMPLER_2D",n[n.SAMPLER_CUBE=35678]="SAMPLER_CUBE",n[n.FLOAT=5126]="FLOAT",n[n.INT=5124]="INT"}(m||(m={}));var P,v=function(n,o,e){this.size=n,this.type=o,this.location=e},x=function(n,o,e){this.size=n,this.type=o,this.location=e},T=function(){function n(){}return n.getWebglVersion=function(){return f.get("webglVersion")},n.createCanvas=function(){return f.get("canvas")||document&&document.createElement("canvas")},n.setWebglVersion=function(n){f.set("webglVersion",n)},n.setWebGLRenderingContext=function(n){return this.gl=n,n},n.getWebGLRenderingContext=function(){return this.gl?this.gl:this.createWebGLRenderingContext()},n.createWebGLRenderingContext=function(){if(this.gl)return this.gl;var n=this.createCanvas();if(!n)return null;n.addEventListener&&n.addEventListener("webglcontextlost",(function(n){throw n.preventDefault(),Error("webgl context is lost~")}),!1);var o=n.getContext("webgl2",this.WEBGL_ATTRIBUTES);return o?f.set("webglVersion",2):(f.set("webglVersion",1),o=n.getContext("webgl",this.WEBGL_ATTRIBUTES)||n.getContext("experimental-webgl",this.WEBGL_ATTRIBUTES)),o},n.printStates=function(n){console.log("1. isBlendEnable = "+n.isEnabled(n.BLEND)),console.log("2. isCullFaceEnable = "+n.isEnabled(n.CULL_FACE)),console.log("3. isDepthTestEnable = "+n.isEnabled(n.DEPTH_TEST)),console.log("4. isDitherEnable = "+n.isEnabled(n.DITHER)),console.log("5. isPolygonOffsetFillEnable = "+n.isEnabled(n.POLYGON_OFFSET_FILL)),console.log("6. isSampleAlphtToCoverageEnable = "+n.isEnabled(n.SAMPLE_ALPHA_TO_COVERAGE)),console.log("7. isSampleCoverageEnable = "+n.isEnabled(n.SAMPLE_COVERAGE)),console.log("8. isScissorTestEnable = "+n.isEnabled(n.SCISSOR_TEST)),console.log("9. isStencilTestEnable = "+n.isEnabled(n.STENCIL_TEST))},n.printWebGLInfo=function(n){console.log("renderer = "+n.getParameter(n.RENDERER)),console.log("version = "+n.getParameter(n.VERSION)),console.log("vendor = "+n.getParameter(n.VENDOR)),console.log("glsl version = "+n.getParameter(n.SHADING_LANGUAGE_VERSION))},n.printWebGLTextureInfo=function(n){console.log("MAX_COMBINED_TEXTURE_IMAGE_UNITS = ",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)),console.log("MAX_TEXTURE_IMAGE_UNITS = ",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)),console.log("MAX_TEXTURE_SIZE = ",n.getParameter(n.MAX_TEXTURE_SIZE)),console.log("MAX_CUBE_MAP_TEXTURE_SIZE = ",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE))},n.triggerContextLostEvent=function(n){var o=n.getExtension("WEBGL_lose_context");null!==o&&o.loseContext()},n.checkGLError=function(n){var o=n.getError();return 0!==o&&(console.log("WebGL Error NO: ",o),!0)},n.setDefaultState=function(n){n.clearColor(0,0,0,0),n.clearDepth(1),n.enable(n.DEPTH_TEST),n.enable(n.CULL_FACE),n.enable(n.SCISSOR_TEST)},n.setViewport=function(n,o){n.viewport(o[0],o[1],o[2],o[3])},n.initShader=function(n,o,e){var t=this.createShader(n,o);return this.compileShader(n,e,t),t},n.createShader=function(n,o){var e;if(null===(e=o===p.VS_SHADER?n.createShader(n.VERTEX_SHADER):n.createShader(n.FRAGMENT_SHADER)))throw new Error("WebGLShader创建失败！");return e},n.compileShader=function(n,o,e){return n.shaderSource(e,o),n.compileShader(e),!1!==n.getShaderParameter(e,n.COMPILE_STATUS)||(console.error(n.getShaderInfoLog(e)),n.deleteShader(e),!1)},n.createProgram=function(n){var o=n.createProgram();if(null===o)throw new Error("WebGLProgram创建失败！");return o},n.linkProgram=function(n,o,e,t,r,i){return void 0===r&&(r=null),void 0===i&&(i=null),n.attachShader(o,e),n.attachShader(o,t),null!==r&&r(n,o),n.linkProgram(o),!1===n.getProgramParameter(o,n.LINK_STATUS)?(console.error(n.getProgramInfoLog(o)),n.deleteShader(e),n.deleteShader(t),n.deleteProgram(o),!1):(n.validateProgram(o),!1===n.getProgramParameter(o,n.VALIDATE_STATUS)?(console.error(n.getProgramInfoLog(o)),n.deleteShader(e),n.deleteShader(t),n.deleteProgram(o),!1):(null!==i&&i(n,o),!0))},n.getProgramActiveAttribs=function(n,o,e){for(var t=n.getProgramParameter(o,n.ACTIVE_ATTRIBUTES),r=0;r<t;r++){var i=n.getActiveAttrib(o,r);i&&(e[i.name]=new x(i.size,i.type,n.getAttribLocation(o,i.name)))}},n.getProgramAtciveUniforms=function(n,o,e){for(var t=n.getProgramParameter(o,n.ACTIVE_UNIFORMS),r=0;r<t;r++){var i=n.getActiveUniform(o,r);if(i){var s=n.getUniformLocation(o,i.name);null!==s&&(e[i.name]=new v(i.size,i.type,s))}}},n.createBuffer=function(n){var o=n.createBuffer();if(null===o)throw new Error("WebGLBuffer创建失败！");return o},n.getColorBufferData=function(n){var o=new Uint8Array(n.drawingBufferWidth*n.drawingBufferHeight*4);return n.readPixels(0,0,n.drawingBufferWidth,n.drawingBufferHeight,n.RGBA,n.UNSIGNED_BYTE,o),o},n.setUniformParam=function(n,o,e,t){switch(e){case c.uniform1f:n.uniform1f(o,t);break;case c.uniform1fv:n.uniform1fv(o,t);break;case c.uniform1i:n.uniform1i(o,t);break;case c.uniform1iv:n.uniform1iv(o,t);break;case c.uniform2f:n.uniform2f(o,t[0],t[1]);break;case c.uniform2fv:n.uniform2fv(o,t);break;case c.uniform2i:n.uniform2i(o,t[0],t[1]);break;case c.uniform2iv:n.uniform2iv(o,t);break;case c.uniform3f:n.uniform3f(o,t[0],t[1],t[2]);break;case c.uniform3fv:n.uniform3fv(o,t);break;case c.uniform3i:n.uniform3i(o,t[0],t[1],t[2]);break;case c.uniform3iv:n.uniform3iv(o,t);break;case c.uniform4f:n.uniform4f(o,t[0],t[1],t[2],t[3]);break;case c.uniform4fv:n.uniform4fv(o,t);break;case c.uniform4i:n.uniform4i(o,t[0],t[1],t[2],t[3]);break;case c.uniform4iv:n.uniform4iv(o,t);break;default:console.error("["+e+"]: unknown uniform type")}},n.genTextureInfoFromTensorShape=function(n,o){var e=n||4096,t=o.shape,r=void 0===t?[]:t,i=r[0],s=r[1],a=r[2],u=r[3];if(i*a<=e&&s*u<=e)o.shape_texture=[i*a,s*u];else{var l=function(){for(var n=0,o=0,e=arguments.length;o<e;o++)n+=arguments[o].length;var t=Array(n),r=0;for(o=0;o<e;o++)for(var i=arguments[o],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t}(r).sort((function(n,o){return n-o})),c=l[0],_=l[1],g=l[2],h=c*l[3],d=_*g;if(h>e||d>e){var p=[h,d].sort((function(n,o){return n-o})),m=p[0],P=p[1],v=function(n,o){var e=o;if(n%e==0)return e;for(;e<n&&n%e!=0;)e++;return e}(P,Math.ceil(P/e));if(h=m*v,d=Math.ceil(P/v),f.get("debug")&&console.error("大小超限",r,[d,h]),h>e||d>e)throw new Error("Requested texture size ["+h+"x"+d+"] greater than WebGL maximum on this browser / GPU ["+e+"x"+e+"].")}o.shape_texture=[d,h]}},n.WEBGL_ATTRIBUTES={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0,powerPreference:"high-performance"},n.gl=null,n}();!function(n){n[n.GL_REPEAT=0]="GL_REPEAT",n[n.GL_MIRRORED_REPEAT=1]="GL_MIRRORED_REPEAT",n[n.GL_CLAMP_TO_EDGE=2]="GL_CLAMP_TO_EDGE"}(P||(P={}));var F=function(){function n(){}return n.getTextureConfig=function(n){var o,e,t,r,i,s,a,u,l=n,c=!0,_=!0;return 2===f.get("webglVersion")?(o=l.getExtension("EXT_color_buffer_float"),t=l.HALF_FLOAT,r=l.R32F,i=l.RGBA32F,s=l.R16F,a=l.RGBA16F,e=l.RED,u=l.RGBA32F):(r=l.RGBA,s=l.RGBA,a=l.RGBA,i=l.RGBA,e=l.RGBA,u=l.RGBA,o=l.getExtension("OES_texture_float"),t=l.getExtension("OES_texture_half_float").HALF_FLOAT_OES,c=this.isDownloadFloatTextureEnabled(l,u),_=this.isFloatTextureReadPixelsEnabledMethod(l,1,c)),{textureFloat:o,textureHalfFloat:t,internalFormat:r,internalFormatPacked:i,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:a,textureFormat:e,downloadInternalFormat:u,frameBufferSupportFloat:c,isFloatTextureReadPixelsEnabled:_}},n.isFloatTextureReadPixelsEnabledMethod=function(n,o,e){var t=n;if(0===o)return!1;if(1===o){if(null==t.getExtension("OES_texture_float"))return!1}else if(null==t.getExtension("EXT_color_buffer_float")||null==t.getExtension("EXT_color_buffer_half_float"))return!1;var r=t.createFramebuffer(),i=t.createTexture();t.bindTexture(t.TEXTURE_2D,i);var s=2===o?t.RGBA32F:t.RGBA;t.texImage2D(t.TEXTURE_2D,0,s,1,1,0,t.RGBA,e?t.FLOAT:t.getExtension("OES_texture_half_float").HALF_FLOAT_OES,null),t.bindFramebuffer(t.FRAMEBUFFER,r),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,i,0);var a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;t.readPixels(0,0,1,1,t.RGBA,t.FLOAT,new Float32Array(4));var u=t.getError()===t.NO_ERROR;return a&&u},n.isDownloadFloatTextureEnabled=function(n,o){var e=n.createTexture();n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,o,1,1,0,n.RGBA,n.FLOAT,null);var t=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,t),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0);var r=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(e),n.deleteFramebuffer(t),r},n.uploadDataToTexture=function(n,o,e,t){n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);var r=e.width_texture,i=e.height_texture,s=e.data,a=n.RGBA,u=n.RGBA,l=n.FLOAT,c=s;if(s instanceof Uint8Array||s instanceof Uint8ClampedArray||!(s instanceof Float32Array||s instanceof Array))l=n.UNSIGNED_BYTE;else if(2===f.get("webglVersion")){var _=f.get("webgl_force_half_float_texture");a=t?_?o.internalFormatPackedHalfFloat:o.internalFormatPacked:_?o.internalFormatHalfFloat:o.internalFormat,u=t?n.RGBA:o.textureFormat}else{for(var g=new Float32Array(r*i*4),h=0;h<s.length;h++)t?g[h]=s[h]:(g[4*h]=s[h],g[4*h+1]=0,g[4*h+2]=0,g[4*h+3]=0);c=g}n.texImage2D(n.TEXTURE_2D,0,a,r,i,0,u,l,c)},n.genOutputTexture=function(n,o,e,t){var r=e.interpType,i=e.width_texture,s=e.height_texture,a=n.createTexture();n.bindTexture(n.TEXTURE_2D,a),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,"LINEAR"===r?n.LINEAR:n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,"LINEAR"===r?n.LINEAR:n.NEAREST),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE);var u=f.get("webgl_force_half_float_texture"),l=u?o.internalFormatPackedHalfFloat:o.internalFormatPacked,c=2===f.get("webglVersion")?u?n.HALF_FLOAT:n.FLOAT:o.frameBufferSupportFloat?n.FLOAT:o.textureHalfFloat,_=t?o.isFloatTextureReadPixelsEnabled?c:n.UNSIGNED_BYTE:null;return n.texImage2D(n.TEXTURE_2D,0,l,i,s,0,n.RGBA,t?_:c,null),n.bindTexture(n.TEXTURE_2D,null),a},n}(),b=["\n    precision highp float;\n    precision highp int;\n\n    attribute vec4 position;\n    varying vec2 vCoord;\n\n    void main() {\n        vCoord.x = (position.x + 1.0) / 2.0;\n        vCoord.y = (position.y + 1.0) / 2.0;\n        gl_Position = position;\n    }\n    ","#version 300 es\n    in vec4 position;\n    out vec2 vCoord;\n\n    void main() {\n        vCoord.x = (position.x + 1.0) / 2.0;\n        vCoord.y = (position.y + 1.0) / 2.0;\n        gl_Position = position;\n    }\n    "],E=new Float32Array([-1,1,-1,-1,1,1,1,-1]),y=["length_shape","length_unformatted_shape","width_shape","height_shape","width_texture","height_texture","offset_x","offset_y","channel","total_shape","numbers_shape"],w={float:["multi_value","bias_value"],bool:["fuse_relu"]};function V(){return"\n    "+(f.get("useModAdaptor")?"\n            int calMod(int a, int b) {\n                float modV = mod(float(a), float(b));\n                if (modV == float(b)) {\n                    modV = 0.0;\n                }\n                return int(modV);\n            }\n        ":"\n            int calMod(int a, int b) {\n                return a - a / b * b;\n            }\n        ")+"\n    "+(f.get("useDivisionAdaptor")?"\n            int calDivision(int a, int b) {\n                return int(float(a) / (float(b) - 0.0001));\n            }\n        ":"\n            int calDivision(int a, int b) {\n                return a / b;\n            }\n        ")+"\n    \n    float tanh_calc(float num) {\n        float res = (exp(2.0 * num) - 1.0) / (exp(2.0 * num) + 1.0);\n        return res;\n    }\n    \n    "}const A="\nivec4 transferFromNHWCtoNCHW(\n    int sumVal,\n    const int channel,\n    const int width_shape,\n    const int height_shape,\n    const int total_shape) {\n\n    int n_origin = int(total_shape/(channel * width_shape * height_shape));\n    int new_a = calMod(sumVal, width_shape);\n    sumVal = int((sumVal - new_a) / width_shape);\n    int new_b = calMod(sumVal, height_shape);\n    sumVal = int((sumVal - new_b) / height_shape);\n    int new_g = calMod(sumVal, channel);\n    sumVal = int((sumVal - new_g) / channel);\n    int new_r = calMod(sumVal, n_origin);\n    return ivec4(new_r,new_g,new_b,new_a);\n}\n";var C="\nfloat prelu(float x, float p, float b) {\n    float result = x;\n    if (x < 0.0) {\n        result = x * p;\n    }\n\n    return result;\n}",O="\nfloat relu6(float x, float threshold, float b) {\n    float result = min(max(0.0, x), threshold);\n    return result;\n}",R="\nfloat leakyRelu(float x, float p, float b) {\n    float result = max(x, x * p);\n    return result;\n}",S="\nfloat scale(float x, float p, float b) {\n    float result = p * x + b;\n    return result;\n}",I="\nfloat scaleWidthBias(float x, float p, float b) {\n    float result = p * (x + b);\n    return result;\n}",L="\nfloat sigmoid(float x, float y, float z) {\n    float result = 1.0 / (1.0 + exp(-x));\n    return result;\n}",k="\n    float hardSigmoid(float x, float slope, float offset) {\n        float result = max(0.0, min(1.0, slope * x + offset));\n        return result;\n    }\n",B="\n    float sqrt(float x, float slope, float offset) {\n        return sqrt(x);\n    }\n",D="\n    float pow_func(float x, float factor, float offset) {\n        return pow(x, factor);\n    }\n",M="\nfloat tanh_func(float x, float y, float z) {\n    return tanh_calc(x);\n}";function U(n,o){var e=o.width_shape,t=o.height_shape,r=o.channel,i=o.width_texture;return"\n    // 根据tensor坐标获取这个tensor位置的值\n    float getValueFromTensorPos_"+n+"(int n, int c, int h, int w) {\n        int index = n * "+e*t*r+" + c * "+e*t+" + h * "+e+" + w;\n        int pos_w = int(mod(float(index), float("+i+")));\n        int pos_h = index / int("+i+");\n        vec4 pixels = TEXTURE2D(texture_"+n+",\n            vec2(\n                (float(pos_w)  + 0.5) / float("+i+"),\n                (float(pos_h) + 0.5) / float("+o.height_texture+")\n            )\n        );\n        // 只用了r通道\n        return pixels.r;\n    }"}function N(n,o){var e=o.channel,t=o.height_shape,r=o.width_texture,i=o.height_texture,s=o.width_shape;return"\n    // 根据tensor坐标获取这个tensor位置的值\n    vec4 getValueFromTensorPosPacking_"+n+"(int n, int c, int h, int w) {\n        int index = n * "+s*t*e+" + c * "+s*t+" + h * "+s+" + w;\n        int pos_w = int(mod(float(index), float("+r+")));\n        int pos_h = index / int("+r+");\n        vec4 pixels = TEXTURE2D(texture_"+n+",\n            vec2(\n                (float(pos_w)  + 0.5) / float("+r+"),\n                (float(pos_h) + 0.5) / float("+i+")\n            )\n        );\n        // 只用了r通道\n        return pixels;\n    }"}function j(n,o){var e=o.numbers_shape,t=o.length_shape;if(1===t)return"\n            int getTensorPosFromArrayIndex_"+n+"(int n) {\n                return calMod(n, "+e[0]+");\n            }\n        ";for(var r="ivec"+t+"("+e.join(", ")+")",i="pos[0] = n / "+e[0]+";",s=1;s<t;s++)i+="\n            n = calMod(n, "+e[s-1]+");\n            pos["+s+"] = calDivision(n, "+e[s]+");\n        ";return"\n    ivec"+t+" shapeVec_"+n+" = "+r+";\n    ivec"+t+" getTensorPosFromArrayIndex_"+n+"(int n) {\n        ivec"+t+" pos;\n        "+i+"\n        return pos;\n    }\n    "}function X(n){return"\n    #define getPixelsFromTexturePos_"+n+"(pos) TEXTURE2D(texture_"+n+", pos)\n    "}function G(n,o){return"\n    vec2 moveTexture2PosToReal_"+n+"(vec2 v) {\n        vec2 v2;\n        v2.x = v.x * float("+o.width_texture+");\n        v2.y = v.y * float("+o.height_texture+");\n        return v2;\n    }\n    "}function H(n){return"uniform sampler2D texture_"+n+";"}function W(n,o,e,t,s){var a,u,l="",c=o.name,_=o.mainFunc,g=o.textureFuncConf,h=void 0===g?{}:g,d=o.commonFuncConf;try{var p=function(n,o,e){for(var t={},r=Object.assign({},o),i=[],s=0,a=n;s<a.length;s++){for(var u=a[s],l=u.name,f={},c=0,_=y;c<_.length;c++)void 0!==u[P=_[c]]&&(f[P]=u[P]);t[l]=f,i.push(l)}for(var g=0,h=Object.keys(w);g<h.length;g++)for(var d=h[g],p=0,m=w[d];p<m.length;p++){var P;void 0!==o[P=m[p]]&&(r[P]=d+"("+o[P]+")")}return o.active_function&&(r.active_function=o.active_function),r.runtime=e,{textureParams:t,opParams:r,active_function:o.active_function}}(e,t,s),m=p.textureParams,P=p.opParams,v=p.active_function,x=2===f.get("webglVersion")?" #version 300 es\n            #ifdef GL_FRAGMENT_PRECISION_HIGH\n            precision highp float;\n            precision highp int;\n        #else\n            precision mediump float;\n            precision mediump int;\n        #endif      \n        ":" #ifdef GL_FRAGMENT_PRECISION_HIGH\n            precision highp float;\n            precision highp int;\n        #else\n            precision highp float;\n            precision highp int;\n        #endif\n        ",T=function(n){var o=n.frameBufferSupportFloat,e=n.isFinalOp,t=n.isFloatTextureReadPixelsEnabled;return 2===f.get("webglVersion")?"\n        // 顶点shader透传的材质坐标\n        in vec2 vCoord;\n        out vec4 outColor;\n        void setOutput(float result) {\n            result = fuse_op(result);\n            outColor.r = result;\n        }\n        void setPackedOutput(vec4 result) {\n            outColor = result;\n        }\n        int calCeil(int a, int b) {\n            return int(ceil(float(a) / float(b)));\n        }\n        "+V()+"\n    ":o?"\n            varying vec2 vCoord;\n            varying vec4 outColor;\n            void setOutput(float result) {\n                result = fuse_op(result);\n                gl_FragColor.r = result;\n            }\n            void setPackedOutput(vec4 result) {\n                gl_FragColor = result;\n            }\n            int calCeil(int a, int b) {\n                return int(ceil(float(a) / float(b)));\n            }\n            "+V()+"\n    ":e&&!t?"\n        varying vec2 vCoord;\n        varying vec4 outColor;\n\n        const float FLOAT_MAX = 1.70141184e38;\n        const float FLOAT_MIN = 1.17549435e-38;\n\n        #define isnan(value) isnan_custom(value)\n        bool isnan_custom(float val) {\n            return (val > 0. || val < 1. || val == 0.) ? false : true;\n        }\n\n        "+V()+"\n\n        int calCeil(int a, int b) {\n            return int(ceil(float(a) / float(b)));\n        }\n\n        lowp vec4 encode_float(highp float v) {\n            if (isnan(v)) {\n            return vec4(255, 255, 255, 255);\n            }\n\n            highp float av = abs(v);\n\n            if(av < FLOAT_MIN) {\n            return vec4(0.0, 0.0, 0.0, 0.0);\n            } else if(v > FLOAT_MAX) {\n            return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n            } else if(v < -FLOAT_MAX) {\n            return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n            }\n\n            highp vec4 c = vec4(0,0,0,0);\n\n            highp float e = floor(log2(av));\n            highp float m = exp2(fract(log2(av))) - 1.0;\n\n            c[2] = floor(128.0 * m);\n            m -= c[2] / 128.0;\n            c[1] = floor(32768.0 * m);\n            m -= c[1] / 32768.0;\n            c[0] = floor(8388608.0 * m);\n\n            highp float ebias = e + 127.0;\n            c[3] = floor(ebias / 2.0);\n            ebias -= c[3] * 2.0;\n            c[2] += floor(ebias) * 128.0;\n\n            c[3] += 128.0 * step(0.0, -v);\n\n            return c / 255.0;\n        }\n\n        void setOutput(float result) {\n                result = fuse_op(result);\n                gl_FragColor = encode_float(result);\n        }\n        ":"\n            #define isnan(value) isnan_custom(value)\n            bool isnan_custom(float val) {\n                return (val > 0. || val < 1. || val == 0.) ? false : true;\n            }\n\n            varying vec2 vCoord;\n            varying vec4 outColor;\n            void setOutput(float result) {\n                result = fuse_op(result);\n                if(isnan(result)) {\n                    gl_FragColor.r = 0.0;\n                }else {\n                    gl_FragColor.r = result;\n                }\n            }\n\n            void setPackedOutput(vec4 result) {\n                gl_FragColor = result;\n            }\n\n            "+V()+"\n\n            int calCeil(int a, int b) {\n                return int(ceil(float(a) / float(b)));\n            }\n        "}(n),F=function(n){var o="",e="";if(n.fuse_opt)for(var t in n.fuse_opt){var i=t,s=0,a=0;switch(t){case"scale":var u=n.fuse_opt.scale.bias_after_scale,l=n.fuse_opt.scale.scale;s=void 0!==l?l:1,a=n.fuse_opt.scale.bias||0,!1===u&&void 0!==u&&(i="scaleWidthBias");break;case"relu":i="prelu";break;case"relu6":s=n.fuse_opt[t].threshold;break;case"hard_sigmoid":i="hardSigmoid",s=n.fuse_opt[t].slope||.2,a=n.fuse_opt[t].offset||.5;break;case"leakyRelu":s=n.fuse_opt[t].alpha;break;case"pow":i="pow_func",s=n.fuse_opt[t].factor||2;break;case"tanh":i="tanh_func"}o+=r[i],e+="res = "+i+"(x, float("+s+"), float("+a+"));"}return"\n        "+o+"\n        \n        float fuse_op(float x) {\n            float res = x;\n            "+e+"\n            return res;\n        }\n    "}(P),b=function(n,o,e,t){if(!n)return"";var r=Object.assign({},n);r["@all"]&&function(n,o){var e=o.filter((function(n){return"out"!==n.name})),t=n["@all"];e.forEach((function(o){var e=o.name;n[e]?n[e].concat(t):n[e]=t})),delete n["@all"]}(r,t);for(var s="",a="",u=0,l=Object.keys(r);u<l.length;u++){var f=l[u];if(o[f]){a+=H(f);for(var c=0,_=r[f];c<_.length;c++){var g=_[c];if(i[g])try{s+=i[g](f,o[f],e)}catch(n){console.error(n)}}}}return"\n    "+a+"\n    "+s+"\n    "}(h,m,P,e),E=function(n){return void 0===n?"":"\n        int layer_run_time = "+n+";\n    "}(s),A=function(n){var o,e,t,r,i;return"\n        \n    vec2 _2d_shape_texture_out = vec2(float("+n.width_texture+"), float("+n.height_texture+"));\n    \n        "+(e=(o=n).height_shape,t=o.width_shape,"\n    ivec4 getOutputTensorPos() {\n        vec2 outCoord = vCoord.xy * (_2d_shape_texture_out);\n        int index = int(outCoord.x) + int(outCoord.y) * int("+o.width_texture+");\n\n        int n1 = int(index / "+(r=t*e*o.channel)+");\n        int c1 = int(calMod(index, "+r+") / "+(i=t*e)+");\n        int h1 = int(calMod(index, "+i+") / "+t+");\n        int w1 = calMod(index, "+t+");\n        return ivec4(n1, c1, h1, w1);\n    }\n    \n    ")}(m.out),C=function(n){if(!n)return"";for(var o="",e=0,t=n;e<t.length;e++){var i=t[e];r[i]&&(o+=r[i])}return o}(d);a=l=" "+x+"\n            "+F+"\n            "+T+"\n            "+C+"\n            "+(v?r[v]:"")+"\n            "+b+"\n            "+E+"\n            "+A+"\n            "+_(m,P)+"\n        ",u=1===f.get("webglVersion")?"texture2D":"texture",l=a.replace(/\bTEXTURE2D\b/g,u)}catch(n){console.error("["+c+"]: "+n)}return l}const z=function(){function n(n,o,e,t){var r=n;this.vShader=o;try{this.fShader=this.initShader(r,e,"fragment"),this.shape=t&&t.shape;var i=this.program=r.createProgram();r.attachShader(i,this.vShader),r.attachShader(i,this.fShader),r.linkProgram(i)}catch(n){throw new Error(n)}}return n.prototype.initShader=function(n,o,e){void 0===e&&(e="vertex");var t,r="vertex"===e?n.VERTEX_SHADER:n.FRAGMENT_SHADER;if("vertex"===e&&this.vShader)t=this.vShader;else if(t=n.createShader(r),"vertex"===e&&(this.vShader=t),n.shaderSource(t,o),n.compileShader(t),!n.getShaderParameter(t,n.COMPILE_STATUS))throw new Error("compile: "+n.getShaderInfoLog(t));return t},n.prototype.setProgram=function(n,o,e){n.useProgram(this.program),e||this.runVertexShader(n,o)},n.prototype.runVertexShader=function(n,o){var e=n.getAttribLocation(this.program,"position");n.enableVertexAttribArray(e),n.bindBuffer(n.ARRAY_BUFFER,o),n.vertexAttribPointer(e,2,n.FLOAT,!1,0,0)},n.Sampler="uSampler",n}();var q,Y=(q=function(n,o){return(q=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,o){n.__proto__=o}||function(n,o){for(var e in o)Object.prototype.hasOwnProperty.call(o,e)&&(n[e]=o[e])})(n,o)},function(n,o){function e(){this.constructor=n}q(n,o),n.prototype=null===o?Object.create(o):(e.prototype=o.prototype,new e)}),Z=function(n,o,e,t){return new(e||(e=Promise))((function(r,i){function s(n){try{u(t.next(n))}catch(n){i(n)}}function a(n){try{u(t.throw(n))}catch(n){i(n)}}function u(n){var o;n.done?r(n.value):(o=n.value,o instanceof e?o:new e((function(n){n(o)}))).then(s,a)}u((t=t.apply(n,o||[])).next())}))},K=function(n,o){var e,t,r,i,s={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function a(i){return function(a){return function(i){if(e)throw new TypeError("Generator is already executing.");for(;s;)try{if(e=1,t&&(r=2&i[0]?t.return:i[0]?t.throw||((r=t.return)&&r.call(t),0):t.next)&&!(r=r.call(t,i[1])).done)return r;switch(t=0,r&&(i=[2&i[0],r.value]),i[0]){case 0:case 1:r=i;break;case 4:return s.label++,{value:i[1],done:!1};case 5:s.label++,t=i[1],i=[0];continue;case 7:i=s.ops.pop(),s.trys.pop();continue;default:if(!((r=(r=s.trys).length>0&&r[r.length-1])||6!==i[0]&&2!==i[0])){s=0;continue}if(3===i[0]&&(!r||i[1]>r[0]&&i[1]<r[3])){s.label=i[1];break}if(6===i[0]&&s.label<r[1]){s.label=r[1],r=i;break}if(r&&s.label<r[2]){s.label=r[2],s.ops.push(i);break}r[2]&&s.ops.pop(),s.trys.pop();continue}i=o.call(n,s)}catch(n){i=[6,n],t=0}finally{e=r=0}if(5&i[0])throw i[1];return{value:i[0]?i[1]:void 0,done:!0}}([i,a])}}};const Q=function(n){function o(){var o=n.call(this)||this;return o.cacheTextures={},o.uniformLocations={},o.texturesMap={},o.queryList=[],o.currentTexture=null,o.width_shape_out=1,o.height_shape_out=1,o.width_texture_out=1,o.height_texture_out=1,o.channel=0,o.total_shape=0,o}return Y(o,n),o.prototype.init=function(){return Z(this,void 0,void 0,(function(){var n;return K(this,(function(o){return n=this.gl=T.createWebGLRenderingContext(),this.gl?(this.glVersion=T.getWebglVersion(),this.textureConf=F.getTextureConfig(n),this.MAX_TEXTURE_SIZE=f.get("MAX_TEXTURE_SIZE")||n.getParameter(n.MAX_TEXTURE_SIZE),n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),this.vertexBuffer=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,this.vertexBuffer),n.bufferData(n.ARRAY_BUFFER,E,n.STATIC_DRAW),this.vShader=T.initShader(n,p.VS_SHADER,b[this.glVersion-1]),this.frameBuffer=n.createFramebuffer(),n.bindFramebuffer(n.FRAMEBUFFER,this.frameBuffer),this.pbo=n.createBuffer(),[2]):[2]}))}))},o.prototype.createProgram=function(n){var o=this,e=n.op,t=n.outTensor,r=n.inputTensors,i=n.shaderParams,s=n.runtime,a=n.isFinalOp,u=null;try{var l=function(){for(var n=0,o=0,e=arguments.length;o<e;o++)n+=arguments[o].length;var t=Array(n),r=0;for(o=0;o<e;o++)for(var i=arguments[o],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t}([t],r);l.forEach((function(n){return T.genTextureInfoFromTensorShape(o.MAX_TEXTURE_SIZE,n)}));var f=W(this.textureConf,e,l,i,s);(u=new z(this.gl,this.vShader,f,t)).fsCode=f;var c=F.genOutputTexture(this.gl,this.textureConf,t,a);this.texturesMap[t.tensorId]=c,this.program=u}catch(n){console.error("webgl createProgram: "+e.name+" -- "+n)}return u},o.prototype.runProgram=function(n,o){var e=this,t=function(n,o){if(2===o&&f.get("performance")){var e=n.getExtension("EXT_disjoint_timer_query_webgl2");if(!e)return;var t=n.createQuery();return n.beginQuery(e.TIME_ELAPSED_EXT,t),t}return null}(this.gl,this.glVersion),r=n.isPackedOp;n.program.forEach((function(t,i){var s=n.outputTensors[i],a=s.tensorId;e.setOutProps(s),"frameBuffer"===n.bufferType?e.attachFrameBuffer(a):e.attachColorBuffer(),t.setProgram(e.gl,e.vertexBuffer,o),e.program=t,e.render(n,o,i,r)})),n.tensorData=null,t&&(this.queryList.push({name:n.name,query:t,count:1}),t=function(n,o,e){if(2===o&&f.get("performance")){var t=n.getExtension("EXT_disjoint_timer_query_webgl2");if(!t)return;n.endQuery(t.TIME_ELAPSED_EXT)}return e}(this.gl,this.glVersion,t))},o.prototype.read=function(n){return Z(this,void 0,void 0,(function(){var o,e,t,r;return K(this,(function(i){switch(i.label){case 0:return f.get("webgl_gpu_pipeline")?(o=this.gl,this.frameBuffer=o.createFramebuffer(),o.bindFramebuffer(o.FRAMEBUFFER,this.frameBuffer),[2,[]]):(e=this.createPBO(),[4,this.createAndWaitForFence()]);case 1:return i.sent(),t=this.downloadFloat32TensorFromBuffer(e),r=n?n.shape:[],f.get("webgl_pack_output")?[2,t.slice(0,g(r))]:[2,t]}}))}))},o.prototype.createPBO=function(){var n,o=this.textureConf;if(2===this.glVersion){var e=this.gl,t=this.pbo;e.bindBuffer(e.PIXEL_PACK_BUFFER,t);var r=16*this.width_texture_out*this.height_texture_out;return e.bufferData(e.PIXEL_PACK_BUFFER,r,e.STREAM_READ),e.readPixels(0,0,this.width_texture_out,this.height_texture_out,e.RGBA,e.FLOAT,0),e.bindBuffer(e.PIXEL_PACK_BUFFER,null),t}var i=this.gl,s=i.FLOAT;return o.isFloatTextureReadPixelsEnabled?n=new Float32Array(this.width_texture_out*this.height_texture_out*4):(n=new Uint8Array(this.width_texture_out*this.height_texture_out*4),s=i.UNSIGNED_BYTE),i.readPixels(0,0,this.width_texture_out,this.height_texture_out,i.RGBA,s,n),o.isFloatTextureReadPixelsEnabled?n:new Float32Array(n.buffer)},o.prototype.createAndWaitForFence=function(){return Z(this,void 0,void 0,(function(){var n,o,e,t,r=this;return K(this,(function(i){return n=this.gl,o=null!=n.fenceSync,e=function(){return!0},o&&(t=n.fenceSync(n.SYNC_GPU_COMMANDS_COMPLETE,0),n.flush(),e=function(){var o=n.clientWaitSync(t,0,0);return o===n.ALREADY_SIGNALED||o===n.CONDITION_SATISFIED}),[2,new Promise((function(n){r.pollItem(e,n)}))]}))}))},o.prototype.pollItem=function(n,o){var e=function(){n()?o():setTimeout(e,1)};e()},o.prototype.downloadFloat32TensorFromBuffer=function(n){var o=4*this.width_texture_out*this.height_texture_out;if(2===this.glVersion){var e=this.gl,t=new Float32Array(o);e.bindBuffer(e.PIXEL_PACK_BUFFER,n),e.getBufferSubData(e.PIXEL_PACK_BUFFER,0,t),e.bindBuffer(e.PIXEL_PACK_BUFFER,null);var r=[];if(f.get("webgl_pack_output"))return Array.from(t);for(var i=0;i<this.width_texture_out*this.height_texture_out;i++)r.push(t[4*i]);return r}var s=n,a=[];for(i=0;i<this.width_texture_out*this.height_texture_out;i++){var u=this.textureConf.isFloatTextureReadPixelsEnabled?4*i:i;a.push(s[u])}return a},o.prototype.setOutProps=function(n){var o=n.width_shape,e=void 0===o?1:o,t=n.height_shape,r=void 0===t?1:t,i=n.width_texture,s=void 0===i?1:i,a=n.height_texture,u=void 0===a?1:a,l=n.channel,f=void 0===l?0:l,c=n.total_shape,_=void 0===c?0:c;this.width_shape_out=e,this.height_shape_out=r,this.width_texture_out=s,this.height_texture_out=u,this.channel=f,this.total_shape=_},o.prototype.attachColorBuffer=function(){var n=this.gl;n.bindFramebuffer(n.FRAMEBUFFER,null),n.canvas.width=this.width_shape_out,n.canvas.height=this.height_shape_out,n.viewport(0,0,n.canvas.width,n.canvas.height),n.scissor(0,0,n.canvas.width,n.canvas.height)},o.prototype.attachFrameBuffer=function(n){this.currentTexture=this.texturesMap[n];var o=this.gl;o.framebufferTexture2D(o.FRAMEBUFFER,o.COLOR_ATTACHMENT0,o.TEXTURE_2D,this.currentTexture,0),o.viewport(0,0,this.width_texture_out,this.height_texture_out),o.scissor(0,0,this.width_texture_out,this.height_texture_out)},o.prototype.render=function(n,o,e,t){var r=this;void 0===o&&(o=!1),void 0===t&&(t=!1);var i=n.inputTensors,s=void 0===i?[]:i,a=n.uniform,u=void 0===a?null:a,l=n.iLayer,f=void 0===l?0:l,c=n.modelName,_=this.gl,g=0;s.forEach((function(n){r.initTexture(g,n,t);var i=r.getUniformLoc("texture_"+n.name,f,o,e,c);i&&_.uniform1i(i,g++)})),u&&this.setUniform(u,f,o,e,c),_.drawArrays(_.TRIANGLE_STRIP,0,4)},o.prototype.initTexture=function(n,o,e){var t,r=this.gl,i=this.textureConf,s=o.tensorId,a=e||o.isPacked,u=o.data;if(o.persistable){this.cacheTextures=this.cacheTextures||{};var l=this.cacheTextures[s];l?(t=l,u&&T.genTextureInfoFromTensorShape(this.MAX_TEXTURE_SIZE,o)):(t=r.createTexture(),this.cacheTextures[s]=t)}else t=this.texturesMap[s];r.activeTexture(r["TEXTURE"+n]),r.bindTexture(r.TEXTURE_2D,t),u&&(F.uploadDataToTexture(r,i,o,a),o.data=null)},o.prototype.setUniform=function(n,o,e,t,r){var i=this,s=Object.keys(n),a=this.gl;s.forEach((function(s){var u=n[s].type,l=n[s].value,f=i.getUniformLoc(s,o,e,t,r);T.setUniformParam(a,f,u,l)}))},o.prototype.getUniformLoc=function(n,o,e,t,r){var i=r+"_";if(e)return this.uniformLocations[i+o][n+t];var s=this.gl.getUniformLocation(this.program.program,n);return this.uniformLocations[i+o]=this.uniformLocations[i+o]||{},this.uniformLocations[i+o][n+t]=s,s},o.prototype.dispose=function(){},o}((function(){})),J={mainFunc:function(n,o){var e=n.origin,t=n.filter,r=n.out,i=n.bias,s=o.groups,a=void 0===s?1:s,u=o.strides,l=void 0===u?[]:u,f=o.paddings,c=void 0===f?[]:f,_=o.dilations,g=void 0===_?[]:_,h=o.fuse_relu,d=o.filter_nearest_vec4,p=o.filter_remainder_vec4,m=o.act_type,P=l[0],v=void 0===P?1:P,x=l[1],T=void 0===x?1:x,F=c[0],b=void 0===F?0:F,E=c[1],y=void 0===E?0:E,w=g[0],V=void 0===w?1:w,A=g[1],C=void 0===A?1:A;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        float res = 0.0;\n\n        // 获取output的坐标\n        int oTensorChannel = (c / ("+r.channel+" / "+a+")) * "+t.channel+";\n        int oy = y * "+v+" - "+b+";\n        for (int fy = 0; fy < "+t.height_shape+"; fy++) {\n            if (oy >= "+e.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                oy += "+V+";\n                continue;\n            }\n            int ox = x * "+T+" - "+y+";\n            for (int fx = 0; fx < "+t.width_shape+"; fx++) {\n                if (ox >= "+e.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += "+C+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < "+d+"; j += 4) {\n                    vec4 fValues = vec4(\n                        getValueFromTensorPos_filter(c, j, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 1, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 2, fy, fx),\n                        getValueFromTensorPos_filter(c, j + 3, fy, fx)\n                    );\n\n                    vec4 oValues = vec4(\n                        getValueFromTensorPos_origin(b, oTensorChannel + j, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 1, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 2, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + j + 3, oy, ox)\n                      );\n\n                    res += dot(fValues, oValues);\n                }\n\n                if ("+p+" == 1) {\n                    res += dot(\n                        getValueFromTensorPos_filter(c, "+d+", fy, fx),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+", oy, ox));\n                } else if ("+p+" == 2) {\n                    vec2 fValues = vec2(\n                        getValueFromTensorPos_filter(c, "+d+", fy, fx),\n                        getValueFromTensorPos_filter(c, "+d+" + 1, fy, fx)\n                    );\n                    vec2 oValues = vec2(\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+", oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+" + 1, oy, ox)\n                      );\n                    res += dot(fValues, oValues);\n                } else if ("+p+" == 3) {\n                    vec3 fValues = vec3(\n                        getValueFromTensorPos_filter(c, "+d+", fy, fx),\n                        getValueFromTensorPos_filter(c, "+d+" + 1, fy, fx),\n                        getValueFromTensorPos_filter(c, "+d+" + 2, fy, fx)\n                    );\n                    vec3 oValues = vec3(\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+", oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+" + 1, oy, ox),\n                        getValueFromTensorPos_origin(b, oTensorChannel + "+d+" + 2, oy, ox)\n                    );\n                    res += dot(fValues, oValues);\n                }\n\n                ox += "+C+";\n            }\n            oy += "+V+";\n        }\n\n        "+(i?"res += getValueFromTensorPos_bias(0, 0, 0, c);":"")+"\n\n        if ("+h+") {\n            res = max(0.0, res);\n        }\n        else if ("+("relu6"===m)+") {\n            res = min(max(0.0, res), 6.0);\n        }\n\n        setOutput(res);\n    }\n    "},textureFuncConf:{filter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],bias:["getValueFromTensorPos"]},behaviors:["adaptPaddings","isApplySeparableConv","batchComputeConv2d","processBias"]};function $(n,o){var e=n[0],t=n[1],r=n[2],i=n[3];if(1===e&&1===t)return[[1,1,r],3,[i],1,[r,i]];var s=n.slice(0,o),a=n.slice(o);return[s,s.length,a,a.length,[s.reduce((function(n,o){return n*o})),a.reduce((function(n,o){return n*o}))]]}function nn(n,o,e){if(1===e)return"\n            int getTensorPosFromArrayIndex_"+n+"(int n) {\n                return calMod(n, "+o[0]+");\n            }\n        ";var t=_(o);return t.push(1),"\n    ivec"+e+" shapeVec_"+n+" = ivec"+e+"("+t.join(", ")+");\n    ivec"+e+" getTensorPosFromArrayIndex_"+n+"(int n) {\n        ivec"+e+" pos;\n        pos[0] = n / shapeVec_"+n+"[0];\n        for (int i = 1; i < "+e+"; i++) {\n            n = calMod(n, shapeVec_"+n+"[i - 1]);\n            pos[i] = n / shapeVec_"+n+"[i];\n        }\n        return pos;\n    }\n    "}function on(n){return 1===n?"int":"ivec"+n}function en(n){var o=n.total_shape,e=n.channel,t=n.height_shape,r=n.width_shape;return[o/e/t/r,e,t,r]}const tn={mainFunc:function(n,o){var e=n.origin,t=o.transpose_X,r=void 0!==t&&t,i=o.transpose_Y,s=void 0!==i&&i,a=o.trans_x,u=void 0!==a&&a,l=o.trans_y,f=r||u,c=s||void 0!==l&&l;return"\n    void main() {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        ivec4 origin_pos = out_pos;\n        if ("+f+") {\n            origin_pos[3] = origin_pos[2];\n        }\n        ivec4 counter_pos = out_pos;\n        if ("+c+") {\n            counter_pos[2] = counter_pos[3];\n        }\n\n        for (int j = 0; j < "+(f?e.height_shape:e.width_shape)+"; j++) {\n            if ("+f+") {\n                origin_pos[2] = j;\n            }\n            else {\n                origin_pos[3] = j;\n            }\n            if ("+c+") {\n                counter_pos[3] = j;\n            }\n            else {\n                counter_pos[2] = j;\n            }\n            float o = getValueFromTensorPos_origin(origin_pos[0], origin_pos[1], origin_pos[2], origin_pos[3]);\n            float c = getValueFromTensorPos_counter(counter_pos[0], counter_pos[1], counter_pos[2], counter_pos[3]);\n            \n            res += c * o;\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]}};function rn(n,o){var e=n[0],t=n[1],r=n[2],i=n[3];if(1===e&&1===t)return[[1,1,r],3,[i],1,[r,i]];var s=n.slice(0,o),a=n.slice(o);return[s,s.length,a,a.length,[s.reduce((function(n,o){return n*o})),a.reduce((function(n,o){return n*o}))]]}function sn(n,o,e){if(1===e)return"\n            int getTensorPosFromArrayIndex_"+n+"(int n) {\n                return calMod(n, "+o[0]+");\n            }\n        ";var t=_(o);return t.push(1),"\n    ivec"+e+" shapeVec_"+n+" = ivec"+e+"("+t.join(", ")+");\n    ivec"+e+" getTensorPosFromArrayIndex_"+n+"(int n) {\n        ivec"+e+" pos;\n        pos[0] = n / shapeVec_"+n+"[0];\n        for (int i = 1; i < "+e+"; i++) {\n            n = calMod(n, shapeVec_"+n+"[i - 1]);\n            pos[i] = n / shapeVec_"+n+"[i];\n        }\n        return pos;\n    }\n    "}function an(n){return 1===n?"int":"ivec"+n}function un(n){var o=n.total_shape,e=n.channel,t=n.height_shape,r=n.width_shape;return[o/e/t/r,e,t,r]}const ln={mainFunc:function(n,o){return"\n    // start函数\n    void main(void) {\n        vec2 outCoord = vCoord.xy * (_2d_shape_texture_out);\n        int index = int(outCoord.x) + int(outCoord.y) * int("+n.out.width_texture+");\n        ivec4 originPos = getTensorPosFromArrayIndex_origin(index);\n        float res = getValueFromTensorPos_origin(originPos[0], originPos[1], originPos[2], originPos[3]);\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getTensorPosFromArrayIndex","getValueFromTensorPos"]}},fn={mainFunc:function(n,o){var e=n.out,t=n.origin,r=o.align_mode,i=void 0===r?1:r,s=o.align_corners,a=void 0===s||s;return"\n    // start函数\n\n    vec4 getData(float n, float scale, bool align_flag, int in_len) {\n        float m = align_flag ? ((n + 0.5) / scale - 0.5) : (n / scale);\n        int a1 = int(floor(m));\n        a1 = a1 > 0 ? a1 : 0;\n        int a2 = (a1 + 1) < (in_len - 1) ? (a1 + 1) : (in_len - 1);\n\n        float idx_src = (n + 0.5) / scale - 0.5;\n        idx_src = idx_src > 0.0 ? idx_src : 0.0;\n        float b1 = align_flag ? (idx_src - float(a1)) : (n / scale - float(a1));\n        float b2 = 1.0 - b1;\n        return vec4(float(a1), float(a2), b1, b2);\n    }\n\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n\n        bool align_flag = "+i+" == 0 && !"+a+";\n\n        float scale_x = 0.0;\n        float scale_y = 0.0;\n        if ("+a+") {\n            scale_x = float("+e.width_shape+" - 1) / float("+t.width_shape+" - 1);\n            scale_y = float("+e.height_shape+" - 1) / float("+t.height_shape+" - 1);\n        }\n        else {\n            scale_x = float("+e.width_shape+") / float("+t.width_shape+");\n            scale_y = float("+e.height_shape+") / float("+t.height_shape+");\n        }\n\n        vec4 vx = getData(float(oPos.a), scale_x, align_flag, "+t.width_shape+");\n        vec4 vy = getData(float(oPos.b), scale_y, align_flag, "+t.height_shape+");\n\n        int x1 = int(vx.r);\n        int x2 = int(vx.g);\n        float x3 = vx.b;\n        float x4 = vx.a;\n        int y1 = int(vy.r);\n        int y2 = int(vy.g);\n        float y3 = vy.b;\n        float y4 = vy.a;\n\n        float value11 = getValueFromTensorPos_origin(oPos.r, oPos.g, y1, x1);\n        float value12 = getValueFromTensorPos_origin(oPos.r, oPos.g, y2, x1);\n        float value21 = getValueFromTensorPos_origin(oPos.r, oPos.g, y1, x2);\n        float value22 = getValueFromTensorPos_origin(oPos.r, oPos.g, y2, x2);\n        float value = x4 * y4 * value11 + x4 * y3 * value12 + x3 * y4 * value21 + x3 * y3 * value22;\n        setOutput(float(value));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},cn=fn;var _n={relu:["transToPrelu"],relu6:["transToRelu6"],leaky_relu:["transToLeakyrelu"],transToLeakyrelu:["transToLeakyrelu"],scale:["transToScale"],sigmoid:["transToSigmoid"],hard_sigmoid:["transToHardSigmoid"],pow:["transToPow"],sqrt:["transToSqrt"],tanh:["transToTanh"]};function gn(n,o){var e=o.multi_value,t=void 0===e?1:e,r=o.bias_value,i=void 0===r?0:r;return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        float o = getPixelsFromTexturePos_origin(vCoord).r;\n        float res = "+o.active_function+"(o, float("+t+"), float("+i+"));\n        setOutput(res);\n    }\n    "}function hn(n){return{mainFunc:gn,textureFuncConf:{origin:["getPixelsFromTexturePos"]},behaviors:_n[n]}}const dn={mainFunc:function(n,o){var e=o.axes,t=Array.isArray(e)?e:[e],r=[0,1,2,3].filter((function(n){return n>=t.length}));return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        o = getValueFromTensorPos_origin("+[0,1,2,3].map((function(n){return t.indexOf(n)>-1?0:"oPos["+r.splice(0,1)+"]"})).join(",")+");\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},pn={mainFunc:function(n,o){var e=n.origin,t=n.out,r=o.align_corners;return"\n    // start函数\n    int getData(float n, float scale, bool align_corners) {\n        float m = align_corners ? (n / scale + 0.5) : (n / scale);\n        return int(floor(m));\n    }\n\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        \n        float scale_x = 0.0;\n        float scale_y = 0.0;\n        if ("+r+") {\n            scale_x = float("+t.width_shape+" -1) / float("+e.width_shape+" - 1);\n            scale_y = float("+t.height_shape+" - 1) / float("+e.height_shape+" - 1);\n        }\n        else {\n            scale_x = float("+t.width_shape+") / float("+e.width_shape+");\n            scale_y = float("+t.height_shape+") / float("+e.height_shape+");\n        }\n    \n        int vx = getData(float(oPos.a), scale_x, "+r+");\n        int vy = getData(float(oPos.b), scale_y, "+r+");\n        \n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, vy, vx);\n        setOutput(float(o));\n}\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]};var mn=function(){for(var n=0,o=0,e=arguments.length;o<e;o++)n+=arguments[o].length;var t=Array(n),r=0;for(o=0;o<e;o++)for(var i=arguments[o],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t};const Pn={mainFunc:function(n,o){var e=n.origin,t=n.image,r=n.out,i=o.variances,s=void 0===i?[.1,.1,.2,.2]:i,a=o.fixed_sizes,u=o.fixed_ratios,l=o.densities,f=o.flatten_to_2d,c=o.clip,g=o.step_w,h=void 0===g?0:g,p=o.step_h,m=void 0===p?0:p,P=o.offset,v=void 0===P?.5:P,x=o.runtime,T=void 0===x?0:x,F=t.height_shape,b=t.width_shape,E=e.height_shape,y=e.width_shape,w=r.total_shape,V=r.channel,A=r.height_shape,C=r.width_shape,O=w/V/A/C,R=_([O,V,A,C]),S=h,I=m;0!==h&&0!==m||(S=b/y,I=F/E);var L=Math.round(.5*(S+I)),k=u.map((function(n){return Math.sqrt(n)})),B=1===k.length?"sqrt_fixed_ratios":"sqrt_fixed_ratios[r]",D=u.length,M=A,U=O,N=V;f&&(U=E,N=y,M=A/E/y);var X=_([U,N,M,C]),G=j("out1",{numbers_shape:mn(X,[1]),length_shape:4}),H=l.map((function(n){return n*n*D})),W=H.length,z=function(n){var o="ivec2 calRemain(int remain, int curAccIndex, int s) {",e=n.length;if(1===e)o+="\n            int accIndex0 = density_acc_shape;\n\n            if (remain >= accIndex0) {\n                s++;\n                remain -= accIndex0;\n            }\n            else {\n                return ivec2(remain, s);\n            }\n            ";else for(var t=0;t<e;t++)o+="\n            int accIndex"+t+" = density_acc_shape["+t+"];\n\n            if (remain >= accIndex"+t+") {\n                s++;\n                remain -= accIndex"+t+";\n            }\n            else {\n                return ivec2(remain, s);\n            }\n            ";return o+"\n    }\n    "}(H),q=c?"v = min(max(v, 0.), 1.);":"",Y=1===W?"density_acc_shape":"density_acc_shape[0]",Z="\n    float getFloat4TensorVal(vec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n    float getFloat3TensorVal(vec3 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n    }\n    float getFloat2TensorVal(vec2 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n    }\n    float getFloat1TensorVal(float tensor, int index) {\n        return tensor;\n    }\n    int getInt4TensorVal(ivec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n    int getInt3TensorVal(ivec3 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n    }\n    int getInt2TensorVal(ivec2 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n    }\n\n    int getInt1TensorVal(int tensor, int index) {\n       return tensor;\n    }\n\n    "+G+"\n    \n        "+d(l,"densities")+"\n        "+d(a,"fixed_sizes")+"\n        "+d(k,"sqrt_fixed_ratios")+"\n        "+function(n,o){if(1===n.length)return"int "+o+" = int("+n[0]+");";for(var e=n.length,t="\n        ivec"+e+" "+o+" = ivec"+e+"(\n    ",r=0;r<e;r++)t+=n[r]+",";return t.slice(0,-1)+");"}(H,"density_acc_shape")+"\n    \n    "+z+"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int rr = int(oPos.r);\n        int gg = int(oPos.g);\n        int bb = int(oPos.b);\n        int aa = int(oPos.a);\n\n        // 输出坐标转换为输入坐标\n        int index = rr * "+R[0]+" + gg * "+R[1]+" + bb * "+R[2]+" + aa;\n        ivec4 realOutPos = getTensorPosFromArrayIndex_out1(index);\n        int h = realOutPos.r;\n        int w = realOutPos.g;\n        int b = realOutPos.b;\n        int a = realOutPos.a;\n    ";return 1===T?"\n        "+d(s,"variances")+"\n        "+Z+"\n        setOutput(getFloat4TensorVal(variances, aa));\n        }":"\n            "+Z+"\n            // 求idx 对应的 s, r, di, dj\n            int s = 0;\n            int remain = b;\n            int curAccIndex = "+Y+";\n\n            ivec2 remainInfo = calRemain(remain, curAccIndex, s);\n            remain = remainInfo[0];\n            s = remainInfo[1];\n            int density = int(getFloat"+l.length+"TensorVal(densities, s));\n            int r = int(floor(float(remain / density / density)));\n            remain -= r * density * density;\n\n            float di = floor(float(remain / density));\n            float dj = float(remain - int(di) * density);\n\n            float center_x = (float(w) + float("+v+")) * float("+S+");\n            float center_y = (float(h) + float("+v+")) * float("+I+");\n            float fixed_size = getFloat"+a.length+"TensorVal(fixed_sizes, s);\n            float shift = float("+L+") / float(density);\n\n            float v = 0.0;\n            if (a == 0 || a == 2) {\n                float box_width_ratio = fixed_size * "+B+";\n                float density_center_x = center_x - float("+L+") / 2. + shift / 2.;\n                float center_x_temp = density_center_x + dj * shift;\n                if (a == 0) {\n                    v = max((center_x_temp - box_width_ratio / 2.) / float("+b+"), 0.);\n                }\n                else {\n                    v = min((center_x_temp + box_width_ratio / 2.) / float("+b+"), 1.);\n                }\n            }\n            else {\n                float box_height_ratio = fixed_size / "+B+";\n                float density_center_y = center_y - float("+L+") / 2. + shift / 2.;\n                float center_y_temp = density_center_y + di * shift;\n                if (a == 1) {\n                    v = max((center_y_temp - box_height_ratio / 2.) / float("+F+"), 0.);\n                }\n                else {\n                    v = min((center_y_temp + box_height_ratio / 2.) / float("+F+"), 1.);\n                }\n            }\n\n            "+q+"\n\n            setOutput(v);\n        }\n        "},textureFuncConf:{image:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]}},vn={mainFunc:function(n,o){var e=n.origin,t=n.image,r=n.out,i=o.variances,s=void 0===i?[.1,.1,.2,.2]:i,a=o.flip,u=o.clip,l=o.step_w,f=void 0===l?0:l,c=o.step_h,_=void 0===c?0:c,g=o.offset,p=void 0===g?.5:g,m=o.runtime,P=void 0===m?0:m,v=o.min_sizes,x=void 0===v?[]:v,T=o.max_sizes,F=void 0===T?[]:T,b=o.aspect_ratios,E=void 0===b?[]:b,y=o.min_max_aspect_ratios_order,w=void 0!==y&&y,V=t.height_shape,A=t.width_shape,C=e.height_shape,O=e.width_shape,R=r.channel,S=r.height_shape,I=f,L=_;0!==f&&0!==_||(I=A/O,L=V/C);var k=[1];E.forEach((function(n){1!==n&&(k.push(Math.sqrt(n)),a&&k.push(Math.sqrt(1/n)))}));var B=k.length,D=u?"res = min(max(res, 0.), 1.);":"",M="\n    float getFloat4TensorVal(vec4 tensor, int index) {\n        if (index == 0) {\n            return tensor[0];\n        }\n        else if (index == 1) {\n            return tensor[1];\n        }\n        else if (index == 2) {\n            return tensor[2];\n        }\n        else if (index == 3) {\n            return tensor[3];\n        }\n    }\n\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int nn = int(oPos.r);\n        int cc = int(oPos.g);\n        int hh = int(oPos.b);\n        int ww = int(oPos.a);\n\n\n        \n        "+h(x,"min_sizes")+"\n        "+h(F,"max_sizes")+"\n        "+h(k,"aspect_ratios")+"\n    \n\n    ";return 1===P?"\n            "+d(s,"variances")+"\n            "+M+"\n            float res = 0.0;\n            res = getFloat4TensorVal(variances, ww);\n            setOutput(float(res));\n        }":"\n            "+M+"\n            int idx = nn * "+R*S+" + cc * "+S+" + hh;\n            int as_num = "+B+";\n            float offset = "+p+";\n            \n            int feature_width = "+O+";\n            int num_priors = "+S+";\n            float step_width = float("+I+");\n            float step_height = float("+L+");\n\n            float im_width = float("+A+");\n            float im_height = float("+V+");\n\n            bool min_max_aspect_ratios_order = "+w+";\n\n            // 求idx 对应的 h w p m\n            int h = int(idx / (num_priors * feature_width));\n            int w = (idx / num_priors) % feature_width;\n            int p = idx % num_priors;\n            int m = "+(F.length>0)+" ? int(p / (as_num + 1)) : int(p / as_num);\n            float cx = (float(w) + offset) * step_width;\n            float cy = (float(h) + offset) * step_height;\n            float min_size = float(min_sizes[m]);\n            float bw = 0.0;\n            float bh = 0.0;\n\n            "+(F.length>0?"\n            int s = p % (as_num + 1);\n            if ("+!w+") {\n                if (s < as_num) {\n                    float ar = aspect_ratios[s];\n                    bw = min_size * ar / 2.0;\n                    bh = min_size / ar / 2.0;\n                }\n                else {\n                    float max_size = float(max_sizes[m]);\n                    bw = sqrt(min_size * max_size) / 2.0;\n                    bh = bw;\n                }\n            }\n            else {\n                if (s == 0) {\n                    bh = min_size / 2.0;\n                    bw = bh;\n                }\n                else if (s == 1) {\n                    float max_size = float(max_sizes[m]);\n                    bw = sqrt(min_size * max_size) / 2.0;\n                    bh = bw;\n                }\n                else {\n                    float ar = aspect_ratios[s - 1];\n                    bw = min_size * sqrt(ar) / 2.0;\n                    bh = min_size / sqrt(ar) / 2.0;\n                }\n            }":"\n            int s = p % as_num;\n            float ar = aspect_ratios[s];\n            bw = min_size * ar / 2.0;\n            bh = min_size / ar / 2.0;\n        ")+"\n            float res = 0.0;\n            if (ww == 0) {\n                res = (cx - bw) / im_width;\n            }\n            else if (ww == 1) {\n                res = (cy - bh) / im_height;\n            }\n            else if (ww == 2) {\n                res = (cx + bw) / im_width;\n            }\n            else {\n                res = (cy + bh) / im_height;\n            }\n\n            "+D+"\n\n            setOutput(float(res));\n        }\n        "},textureFuncConf:{image:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:[]};var xn={arg_max:{mainFunc:function(n,o){var e=n.origin,t=o.axis,r=void 0===t?-1:t,i=o.flatten,s=e.total_shape,a=e.height_shape,u=e.width_shape,l=e.channel,f=e.length_unformatted_shape,c=s/(u*a*l),_=r<0?3:4-f+r,g=[c,l,a,u][_];return"\n\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        int pos = 0;\n        if ("+!i+") {\n            if ("+_+" == 1) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, 0, oPos.b, oPos.a);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, index, oPos.b, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+_+" == 2) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, 0, oPos.a);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, index, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+_+" == 3) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, 0);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, index);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else {\n                float tmp = getValueFromTensorPos_origin(0, oPos.g, oPos.b, oPos.a);\n                for (int index = 0; index < "+g+"; index++) {\n                    o = getValueFromTensorPos_origin(index, oPos.g, oPos.b, oPos.a);\n                    if (o > tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n        }\n        else {\n            int index = 0;\n            float tmp = getValueFromTensorPos_origin(0, 0, 0, 0);\n            for (int n = 0; n < "+c+"; n++) {\n                for (int c = 0; c < "+l+"; c++) {\n                    for (int h = 0; h < "+a+"; h++) {\n                        for (int w = 0; w < "+u+"; w++) {\n                            o = getValueFromTensorPos_origin(n, c, h, w);\n                            if (o > tmp) {\n                                tmp = o;\n                                pos = index;\n                            }\n                            index++;\n                        }\n                    }\n                }\n            }\n        }\n        setOutput(float(pos));\n    }"},textureFuncConf:{origin:["getValueFromTensorPos"]}},arg_min:{mainFunc:function(n,o){for(var e=n.origin,t=o.axis,r=void 0===t?-1:t,i=o.flatten,s=e.total_shape,a=e.height_shape,u=e.width_shape,l=e.channel,f=s/(u*a*l),c=[f,l,a,u],_=0,g=0;g<4&&!(c[g]>1);g++)_++;var h=r<0?4-_+r:r,d=c[h=_+h];return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        int pos = 0;\n        if ("+!i+") {\n            if ("+h+" == 1) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, 0, oPos.b, oPos.a);\n                for (int index = 0; index < "+d+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, index, oPos.b, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+h+" == 2) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, 0, oPos.a);\n                for (int index = 0; index < "+d+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, index, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n            else if ("+h+" == 3) {\n                float tmp = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, 0);\n                for (int index = 0; index < "+d+"; index++) {\n                    o = getValueFromTensorPos_origin(oPos.g, oPos.b, oPos.a, index);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }     \n            }\n            else {\n                float tmp = getValueFromTensorPos_origin(0, oPos.g, oPos.b, oPos.a);\n                for (int index = 0; index < "+d+"; index++) {\n                    o = getValueFromTensorPos_origin(index, oPos.g, oPos.b, oPos.a);\n                    if (o < tmp) {\n                        tmp = o;\n                        pos = index;\n                    }\n                }\n            }\n        }\n        else {\n            int index = 0;\n            float tmp = getValueFromTensorPos_origin(0, 0, 0, 0);\n            for (int n = 0; n < "+f+"; n++) {\n                for (int c = 0; c < "+l+"; c++) {\n                    for (int h = 0; h < "+a+"; h++) {\n                        for (int w = 0; w < "+u+"; w++) {\n                            o = getValueFromTensorPos_origin(n, c, h, w);\n                            if (o < tmp) {\n                                tmp = o;\n                                pos = index;\n                            }\n                            index++;\n                        }\n                    }\n                }\n            }\n        }\n        setOutput(float(pos));\n    }"},textureFuncConf:{origin:["getValueFromTensorPos"]}},conv2d:J,conv2d_packing:{mainFunc:function(n,o){var e=n.origin,t=n.filter,r=n.out,i=n.bias,s=o.groups,a=void 0===s?1:s,u=o.strides,l=void 0===u?[]:u,f=o.paddings,c=void 0===f?[]:f,_=o.dilations,g=void 0===_?[]:_,h=o.fuse_relu,d=o.act_type,p=l[0],m=void 0===p?1:p,P=l[1],v=void 0===P?1:P,x=c[0],T=void 0===x?0:x,F=c[1],b=void 0===F?0:F,E=g[0],y=void 0===E?1:E,w=g[1],V=void 0===w?1:w;return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        vec4 res = vec4(0.0, 0.0, 0.0, 0.0);\n\n        int oy = y * "+m+" - "+T+";\n        for (int fy = 0; fy < "+t.height_shape+"; fy++) {\n            if (oy >= "+e.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                oy += "+y+";\n                continue;\n            }\n            int ox = x * "+v+" - "+b+";\n            for (int fx = 0; fx < "+t.width_shape+"; fx++) {\n                if (ox >= "+e.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += "+V+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < "+t.channel+"; j += 1) {\n                    int c0 = (c / ("+r.channel+" * 4 / "+a+")) * "+t.channel+" + j;\n                    vec4 fValue = getValueFromTensorPosPacking_filter(c * 4, j, fy, fx);\n                    vec4 oValue = getValueFromTensorPosPacking_origin(b, c0, oy, ox);\n\n                    for (int packed_index = 0; packed_index < 4; packed_index++) {\n                        if (packed_index == 0) {\n                            res.r += dot(fValue, oValue);\n                        } else if (packed_index == 1) {\n                            int c1 = ((c + 1) / ("+r.channel+" * 4 / "+a+")) * "+t.channel+" + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c1, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 1, j, fy, fx);\n                            res.g += dot(fValue, oValue);\n                        } else if (packed_index == 2) {\n                            int c2 = ((c + 2) / ("+r.channel+" * 4 / "+a+")) * "+t.channel+" + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c2, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 2, j, fy, fx);\n                            res.b += dot(fValue, oValue);\n                        } else if (packed_index == 3) {\n                            int c3 = ((c + 3) / ("+r.channel+" * 4 / "+a+")) * "+t.channel+" + j;\n                            oValue = getValueFromTensorPosPacking_origin(b, c3, oy, ox);\n                            fValue = getValueFromTensorPosPacking_filter(c * 4 + 3, j, fy, fx);\n                            res.a += dot(fValue, oValue);\n                        }\n                    }\n                }\n                ox += "+V+";\n            }\n            oy += "+y+";\n        }\n\n        "+(i?"res += getValueFromTensorPosPacking_bias(0, c, 0, 0);":"")+"\n\n        if ("+h+") {\n            res = max(vec4(0.0, 0.0, 0.0, 0.0), res);\n        }\n        else if ("+("relu6"===d)+") {\n            res = min(max(vec4(0.0, 0.0, 0.0, 0.0), res), vec4(6.0, 6.0, 6.0, 6.0));\n        }\n        setPackedOutput(res);\n    }\n    "},textureFuncConf:{filter:["getValueFromTensorPosPacking"],origin:["getValueFromTensorPosPacking"],bias:["getValueFromTensorPosPacking"]},behaviors:["adaptPaddings","isApplySeparableConv","batchComputeConv2d","processBias"]},conv2d_transpose:{mainFunc:function(n,o){var e=n.origin,t=n.filter,r=n.out,i=o.groups,s=void 0===i?1:i,a=o.strides,u=void 0===a?[]:a,l=o.paddings,f=void 0===l?[]:l,c=o.dilations,_=void 0===c?[]:c,g=u[0],h=void 0===g?1:g,d=u[1],p=void 0===d?1:d,m=f[0],P=void 0===m?0:m,v=f[1],x=void 0===v?0:v;x=t.height_shape-x-1,P=t.width_shape-P-1;var T=_[0],F=void 0===T?1:T,b=_[1],E=void 0===b?1:b;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        float res = 0.0;\n        int temp_x = 0;\n        int temp_y = 0;\n        float o = 0.0;\n        float f = 0.0;\n\n        // 获取output的坐标\n        int oTensorChannel = int(c * "+s+" / "+r.channel+") * "+e.channel+";\n        int oy = y - "+x+";\n        const int groupLen = int("+e.channel+" / "+s+");\n        int groupIndex = int(c / groupLen);\n\n        for (int fy = 0; fy < "+t.height_shape+"; fy++) {\n            if (oy < 0) {\n                oy += "+F+";\n                continue;\n            }\n            int ox = x - "+P+";\n            for (int fx = 0; fx < "+t.width_shape+"; fx++) {\n\n                if (ox < 0) {\n                    ox += "+E+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < groupLen; j++) {\n                    int curIndex = j + b * groupLen;\n                    if (calMod(ox, int("+p+")) == 0 && calMod(oy, int("+h+")) == 0) {\n                        temp_x = int(floor(float(ox) / float("+p+")));\n                        temp_y = int(floor(float(oy) / float("+h+")));\n                        if (temp_x < "+e.width_shape+" && temp_y < "+e.height_shape+") {\n                            o = getValueFromTensorPos_origin(b, curIndex , temp_y, temp_x);\n                            f = getValueFromTensorPos_filter(\n                                curIndex,\n                                int(c / "+s+"),\n                                "+t.height_shape+"-1-fy,\n                                "+t.width_shape+"-1-fx\n                            );\n                            res += f * o;\n                        }\n                    }\n                }\n                ox += "+E+";\n            }\n            oy += "+F+";\n        }\n        setOutput(float(res));\n    }\n"},textureFuncConf:{filter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["adaptPaddings","isApplySeparableConv","batchComputeConv2d","processBias"]},depthwise_conv2d:J,conv2d_depthwise:J,conv2d_elementwise_add:{mainFunc:function(n,o){var e=n.origin,t=n.filter,r=n.out,i=n.counter,s=o.active_function,a=o.groups,u=void 0===a?1:a,l=o.axis,f=o.strides,c=void 0===f?[]:f,_=o.paddings,g=void 0===_?[]:_,h=o.dilations,d=void 0===h?[]:h,p=o.multi_value,m=o.bias_value,P=c[0],v=void 0===P?1:P,x=c[1],T=void 0===x?1:x,F=g[0],b=void 0===F?0:F,E=g[1],y=void 0===E?0:E,w=d[0],V=void 0===w?1:w,A=d[1],C=void 0===A?1:A;return"\n    // start函数\n\n    float getValueFromCounter(int index) {\n        float xPos = float(index) / float("+i.width_shape+");\n        vec4 pixels = TEXTURE2D(texture_counter, vec2(xPos, 0.5));\n        return pixels.r;\n    }\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n\n        int x = oPos.a;\n        int c = oPos.g;\n        int y = oPos.b;\n        int b = oPos.r;\n        int addAxis = oPos["+l+"];\n        float res = getValueFromCounter(addAxis);\n\n        // 获取output的坐标\n        int oTensorChannel = (c / ("+r.channel+" / "+u+")) * "+t.channel+";\n        int oy = y * "+v+" - "+b+";\n        for (int fy = 0; fy < "+t.height_shape+"; fy++) {\n            if (oy >= "+e.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                oy += "+V+";\n                continue;\n            }\n            int ox = x * "+T+" - "+y+";\n            for (int fx = 0; fx < "+t.width_shape+"; fx++) {\n                if (ox >= "+e.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    ox += "+C+";\n                    continue;\n                }\n                // channel计算\n                for (int j = 0; j < "+t.channel+"; j++) {\n                    float f = getValueFromTensorPos_filter(c, j, fy, fx);\n                    float o = getValueFromTensorPos_origin(b, oTensorChannel + j, oy, ox);\n                    res += f * o;\n                }\n                ox += "+C+";\n            }\n            oy += "+V+";\n        }\n        setOutput("+s+"(res,  "+p+",  "+m+"));\n    }\n"},textureFuncConf:{filter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]},behaviors:["mergeAttrs","checkIsMerge","setActiveFunc"]},pool2d:{mainFunc:function(n,o){var e=n.origin,t=o.strides,r=void 0===t?[]:t,i=o.paddings,s=void 0===i?[]:i,a=o.pooling_type,u=o.ksize,l=r[0],f=void 0===l?1:l,c=r[1],_=void 0===c?1:c,g=s[0],h=void 0===g?0:g,d=s[1],p=void 0===d?0:d,m=u[0],P=u[1];return"\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        if ("+a+" == 1) {\n            res = -1.70141184e38;\n        }\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // X、Y方向的移动步长\n        int count_pool = 0;\n        int oy_base = out_pos[2] * "+f+" - "+h+";\n        int ox_base = out_pos[3] * "+_+" - "+p+";\n        for (int fy = 0; fy < "+m+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+e.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+P+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+e.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                if ("+a+" == 1) {\n                    if (curr > res) {\n                        res = curr;\n                    }\n                } else {\n                    res += curr;\n                    // 在平均池化模式忽略填充值(exclusive默认为true）\n                    count_pool++;\n                }\n            }\n        }\n        if ("+a+" != 1) {\n            res = res / float(count_pool);\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["isMax","setPacked","setAdaptive","isGlobalPooling"]},pool2d_max:{mainFunc:function(n,o){var e=n.origin,t=o.strides,r=void 0===t?[]:t,i=o.paddings,s=void 0===i?[]:i,a=o.ksize,u=o.global_pooling,l=o.runtime,f=r[0],c=void 0===f?1:f,_=r[1],g=void 0===_?1:_,h=s[0],d=void 0===h?0:h,p=s[1],m=void 0===p?0:p,P=a[0],v=a[1],x=function(n){var o=n.total_shape,e=n.channel,t=n.height_shape,r=n.width_shape;return[o/e/t/r,e,t,r]}(e),T="",F="setOutput(float(res));";return 0===l&&!0===u&&(T="\n            if (curr > res) {\n                index = "+x[2]*x[3]+" * out_pos[1] + "+x[3]+" * oy + ox;\n            }\n        ",F="setOutput(float(index));"),"\n    // start函数\n    void main(void) {\n        float res = -1.70141184e38;\n        int index = 0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        int b = out_pos[0];\n        int c = out_pos[1];\n        int y = out_pos[2];\n        int x = out_pos[3];\n        // X、Y方向的移动步长\n        int oy_base = out_pos[2] * "+c+" - "+d+";\n        int ox_base = out_pos[3] * "+g+" - "+m+";\n        for (int fy = 0; fy < "+P+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+e.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+v+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+e.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                "+T+"\n                res = max(res, curr);\n            }\n        }\n        "+F+"\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["isMax","setPacked","setAdaptive","isGlobalPooling"]},pool2d_winograd:{mainFunc:function(n,o){var e=n.origin,t=n.pool,r=o.strides,i=void 0===r?[]:r,s=o.paddings,a=void 0===s?[]:s,u=o.type_pool,l=i[0],f=void 0===l?1:l,c=i[1],_=void 0===c?1:c,g=a[0],h=void 0===g?0:g,d=a[1],p=void 0===d?0:d,m=e.height_shape,P=e.width_texture,v=e.height_texture;return"\n\n    float getValueFromTensorPosPacked_origin(int r, int g, int b, int a) {\n        int y = b / 2;\n        int yOffset = calMod(b, 2);\n        int x = a / 2;\n        int xOffset = calMod(a, 2);\n        int height = "+m+" + "+e.offset_y+";\n        vec4 pixels = TEXTURE2D(\n            texture_origin,\n            vec2((float(x) + 0.5) / float("+P+"),\n            (float(g * height / 2 + y) + 0.5) / float("+v+"))\n        );\n        int index = 0;\n        if (xOffset == 0 && yOffset == 0) {\n            return pixels[0];\n        }\n        else if (xOffset == 1 && yOffset == 0) {\n            return pixels[1];\n        }\n        else if (xOffset == 0 && yOffset == 1) {\n            return pixels[2];\n        }\n        return pixels[3];\n    }\n\n    // start函数\n    void main(void) {\n        float res = (-1.0 / exp(-20.0));\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // int b = out_pos[0];\n        // int c = out_pos[1];\n        // int y = out_pos[2];\n        // int x = out_pos[3];\n        // X、Y方向的移动步长\n        int count_pool = 0;\n        int oy_base = out_pos[2] * "+f+" - "+h+";\n        int ox_base = out_pos[3] * "+_+" - "+p+";\n\n        for (int fy = 0; fy < "+t.height_shape+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+e.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+t.width_shape+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+e.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPosPacked_origin(out_pos[0], out_pos[1], oy, ox);\n                if ("+u+" == 1) {\n                    if (curr > res) {\n                        res = curr;\n                    }\n                } else {\n                    res += curr;\n                    // 在平均池化模式忽略填充值(exclusive默认为true）\n                    count_pool++;\n                }\n            }\n        }\n        if ("+u+" != 1) {\n            res = res / float(count_pool);\n        }\n        setOutput(res);\n    }\n    "},behaviors:["isMax","setPacked","setAdaptive","isGlobalPooling"]},elementwise_add:{mainFunc:function(n,o){var e=o.counterPos,t=o.Scale_y,r=void 0===t?1:t,i=o.Scale_x,s=void 0===i?1:i,a=o.Scale_out,u=void 0===a?1:a;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter("+e+");\n        float res = float("+u/r+") * c + float("+u/s+") * o;\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_mul:{mainFunc:function(n,o){var e=n.counter,t=o.counterPos,r=o.Scale_y,i=void 0===r?1:r,s=o.Scale_x,a=void 0===s?1:s,u=o.Scale_out,l=void 0===u?1:u;return"\n    ivec4 formatNCHW(int n, int c, int h, int w) {\n        int newN = n;\n        int newC = c;\n        int newH = h;\n        int newW = w;\n\n        if (n >= "+e.height_texture/e.height_shape+") {\n            newN = int("+e.height_texture/e.height_shape+");\n        }\n        if (c >= "+e.channel+") {\n            newC = int("+(e.channel-1)+");\n        }\n        if (h >= "+e.height_shape+") {\n            newH = "+(e.height_shape-1)+";\n        }\n        if (w >= "+e.width_shape+") {\n            newW = "+(e.width_shape-1)+";\n        }\n        return ivec4(newN, newC, newH, newW);\n    }\n\n    // start函数\n    void main() {\n        // 输出数据\n        ivec4 oPos1 = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n        ivec4 oPos = formatNCHW(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n\n        float c = getValueFromTensorPos_counter("+t+");\n        float res = float("+l/a+") * o * float("+1/i+") * c;\n        setOutput(float(res));\n    }\n\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_div:{mainFunc:function(n,o){var e=n.counter,t=o.counterPos,r=o.Scale_y,i=void 0===r?1:r,s=o.Scale_x,a=void 0===s?1:s,u=o.Scale_out,l=void 0===u?1:u;return"\n    ivec4 formatNCHW(int n, int c, int h, int w) {\n        int newN = n;\n        int newC = c;\n        int newH = h;\n        int newW = w;\n\n        if (n >= "+e.height_texture/e.height_shape+") {\n            newN = int("+e.height_texture/e.height_shape+");\n        }\n        if (c >= "+e.channel+") {\n            newC = int("+(e.channel-1)+");\n        }\n        if (h >= "+e.height_shape+") {\n            newH = "+(e.height_shape-1)+";\n        }\n        if (w >= "+e.width_shape+") {\n            newW = "+(e.width_shape-1)+";\n        }\n        return ivec4(newN, newC, newH, newW);\n    }\n\n    // start函数\n    void main() {\n        // 输出数据\n        ivec4 oPos1 = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n        ivec4 oPos = formatNCHW(oPos1.r, oPos1.g, oPos1.b, oPos1.a);\n\n        float c = getValueFromTensorPos_counter("+t+");\n        float res = float("+l+") * (float("+1/a+") * o / (float("+1/i+") * c));\n        setOutput(float(res));\n    }\n\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_pow:{mainFunc:function(n,o){var e=o.counterPos,t=o.Scale_y,r=void 0===t?1:t,i=o.Scale_x,s=void 0===i?1:i,a=o.Scale_out,u=void 0===a?1:a;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter("+e+");\n        float res = pow(float("+u/s+") * o, float("+u/r+") * c);\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},elementwise_sub:{mainFunc:function(n,o){var e=o.counterPos,t=o.Scale_y,r=void 0===t?1:t,i=o.Scale_x,s=void 0===i?1:i,a=o.Scale_out,u=void 0===a?1:a;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        float c = getValueFromTensorPos_counter("+e+");\n        float res = float("+u/s+") * o - float("+u/r+") * c;\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]},behaviors:["processElementwiseAxis","genElementwiseCounterPos"]},mul:{mainFunc:function(n,o){var e=n.origin,t=n.counter,r=o.x_num_col_dims,i=o.y_num_col_dims,s=en(e),a=en(t),u=$(s,r),l=u[0],f=u[1],c=u[2],_=u[3],g=u[4],h=$(a,i),d=h[0],p=h[1],m=h[2],P=h[3];return"\n    "+nn("x1",l,f)+"\n    "+nn("x2",c,_)+"\n    "+nn("y1",d,p)+"\n    "+nn("y2",m,P)+"\n\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 opos = getOutputTensorPos();\n        float temp = 0.0;\n\n        // output is 2D\n        int b = opos.b;\n        int a = opos.a;\n\n        "+on(f)+" x1 = getTensorPosFromArrayIndex_x1(b);\n        "+on(P)+" y2 = getTensorPosFromArrayIndex_y2(a);\n\n        for (int j = 0; j < "+g[1]+"; j++) {\n            "+on(_)+" x2 = getTensorPosFromArrayIndex_x2(j);\n            "+on(p)+" y1 = getTensorPosFromArrayIndex_y1(j);\n\n            ivec4 xPos = ivec4("+on(f)+"(x1), "+on(_)+"(x2));\n            ivec4 yPos = ivec4("+on(p)+"(y1), "+on(P)+"(y2));\n\n            float o = getValueFromTensorPos_origin(xPos.r, xPos.g, xPos.b, xPos.a);\n            float c = getValueFromTensorPos_counter(yPos.r, yPos.g, yPos.b, yPos.a);\n            res += c * o;\n        }\n\n        setOutput(res);\n    }\n    "},textureFuncConf:{counter:["getValueFromTensorPos"],origin:["getValueFromTensorPos"]}},matmul:tn,matmul_v2:tn,fc:{mainFunc:function(n,o){var e=n.origin,t=n.weight,r=o.x_num_col_dims,i=o.y_num_col_dims,s=un(e),a=un(t),u=rn(s,r),l=u[0],f=u[1],c=u[2],_=u[3],g=u[4],h=rn(a,i),d=h[0],p=h[1],m=h[2],P=h[3];return"\n    "+sn("x1",l,f)+"\n    "+sn("x2",c,_)+"\n    "+sn("y1",d,p)+"\n    "+sn("y2",m,P)+"\n\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 opos = getOutputTensorPos();\n        float bias = getValueFromTensorPos_bias(opos.r, opos.g, opos.b, opos.a);\n        float temp = 0.0;\n\n        // output is 2D\n        int b = opos.b;\n        int a = opos.a;\n\n        "+an(f)+" x1 = getTensorPosFromArrayIndex_x1(b);\n        "+an(P)+" y2 = getTensorPosFromArrayIndex_y2(a);\n\n        for (int j = 0; j < "+g[1]+"; j++) {\n            "+an(_)+" x2 = getTensorPosFromArrayIndex_x2(j);\n            "+an(p)+" y1 = getTensorPosFromArrayIndex_y1(j);\n\n            ivec4 xPos = ivec4("+an(f)+"(x1), "+an(_)+"(x2));\n            ivec4 yPos = ivec4("+an(p)+"(y1), "+an(P)+"(y2));\n\n            float o = getValueFromTensorPos_origin(xPos.r, xPos.g, xPos.b, xPos.a);\n            float c = getValueFromTensorPos_weight(yPos.r, yPos.g, yPos.b, yPos.a);\n            res += c * o;\n        }\n\n        res = res + bias;\n        setOutput(res);\n    }\n    "},textureFuncConf:{weight:["getValueFromTensorPos"],origin:["getValueFromTensorPos"],bias:["getValueFromTensorPos"]}},dropout:{mainFunc:function(n,o){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        if ("+("downgrade_in_infer"===o.dropout_implementation)+") {\n            o = o * (1.0 - "+o.dropout_prob+");\n        }\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},concat:{mainFunc:function(n,o){var e=o.dim,t=Object.keys(n).filter((function(n){return"out"!==n})).map((function(o){return n[o]})).map((function(n){var o=n.width_shape,t=n.height_shape,r=n.channel;return[n.total_shape/(o*t*r),r,t,o][e]})),r=t.map((function(n,o){return t.slice(0,o+1).reduce((function(n,o){return n+o}),0)})),i="";return r.forEach((function(n,o){i+=0===o?"\n            if (oPos["+e+"] < "+n+") {\n                o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            ":"\n            else if (oPos["+e+"] < "+n+") {\n                oPos["+e+"] = oPos["+e+"] - "+r[o-1]+";\n                o = getValueFromTensorPos_origin_"+o+"(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            "})),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        "+i+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos"]},behaviors:["normalizeDim"]},concat_mul:{mainFunc:function(n,o){var e=o.dim,t=Object.keys(n).filter((function(n){return"out"!==n})).map((function(o){return n[o]})).map((function(n){var o=n.width_shape,t=n.height_shape,r=n.channel;return[n.total_shape/(o*t*r),r,t,o][e]})),r=t.map((function(n,o){return t.slice(0,o+1).reduce((function(n,o){return n+o}),0)})),i="";return r.forEach((function(n,o){i+=0===o?"\n            if (oPos["+e+"] < "+n+") {\n                o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n            }":"\n            else if (oPos["+e+"] < "+n+") {\n                oPos["+e+"] = oPos["+e+"] - "+r[o-1]+";\n                o = getValueFromTensorPos_origin_"+o+"(oPos.r, oPos.g, oPos.b, oPos.a);\n            }\n            "})),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        "+i+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos"]},behaviors:["normalizeDim"]},split:{mainFunc:function(n,o){var e=o.target_length,t=o.num,r=o.dim;return"\n    // start函数\n    void main(void) {\n        int length = int("+e+" / "+t+");\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        oPos["+r+"] = oPos["+r+"] + layer_run_time * length;\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizeDim"]},softmax:{mainFunc:function(n,o){var e=n.origin,t=o.axis,r=t;return(!t||t<0)&&(r=(t||-1)+4),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        const int n = int("+e.total_shape+"/"+e.channel+"/"+e.height_shape+"/"+e.width_shape+");\n        float o = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], oPos[3]);\n        // 输出坐标转换为输入坐标\n        float total = 0.0;\n        float res = 0.0;\n        if ("+r+" == 0) {\n            for (int i = 0; i < n; i++){\n            float temp = getValueFromTensorPos_origin(i, oPos[1], oPos[2], oPos[3]);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        else if ("+r+" == 1) {\n            for (int i = 0; i < "+e.channel+"; i++){\n            float temp = getValueFromTensorPos_origin(oPos[0], i, oPos[2], oPos[3]);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        else {\n            for (int i = 0; i < "+e.width_shape+"; i++){\n            float temp = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], i);\n            total += exp(temp);\n            }\n            res = exp(o) / total;\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},batchnorm:{mainFunc:function(n,o){var e=n.bias,t=n.scale,r=n.mean,i=n.variance,s=o.epsilon;return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        // 归一化数据\n        vec4 scale = getPixelsFromTexturePos_scale(vec2( float(oPos.g) / float("+t.width_texture+") + 0.00001, 0.0));\n        vec4 bias = getPixelsFromTexturePos_bias(vec2( float(oPos.g) / float("+e.width_texture+") + 0.00001, 0.0));\n        vec4 mean = getPixelsFromTexturePos_mean(vec2((float(oPos.g)) / float("+r.width_texture+")  + 0.00001, 0.0));\n        vec4 variance = getPixelsFromTexturePos_variance(\n            vec2((float(oPos.g)) / float("+i.width_texture+") + 0.00001,\n            0.0)\n        );\n\n        float x = (o - mean[0]) / sqrt(variance[0] + "+s+");\n        float res = scale[0] * x + bias[0];\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],scale:["getPixelsFromTexturePos"],bias:["getPixelsFromTexturePos"],mean:["getPixelsFromTexturePos"],variance:["getPixelsFromTexturePos"]}},reshape:ln,reshape2:ln,bilinear_interp:fn,transpose2:{mainFunc:function(n,o){var e=o.perm_arr,t=o.perm_size,r=e[0],i=e[1],s=e[2];return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n\n        // 转置 坐标变换\n        float o = 0.0;\n        if ("+t+" == 1) {\n            o = getValueFromTensorPos_origin(oPos[0], oPos[1], oPos[2], oPos[3]);\n        }\n        else if ("+t+" == 2) {\n            o = getValueFromTensorPos_origin(\n                oPos[0], oPos[1],\n                oPos[(2 + "+r+") > 3 ? 3 : (2 + "+r+")],\n                oPos[(2 + "+i+") > 3 ? 3 : (2 + "+i+")]\n            );\n        }\n        else if ("+t+" == 3) {\n            o = getValueFromTensorPos_origin(\n                oPos[0],\n                oPos[(1 + "+r+") > 3 ? 3 : (1 + "+r+")],\n                oPos[(1 + "+i+") > 3 ? 3 : (1 + "+i+")],\n                oPos[(1 + "+s+") > 3 ? 3 : (1 + "+s+")]\n            );\n        }\n        else if ("+t+" == 4) {\n            o = getValueFromTensorPos_origin(\n                oPos["+r+"],\n                oPos["+i+"],\n                oPos["+s+"],\n                oPos["+e[3]+"]\n            );\n        }\n\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizePerm"]},unpacked_2_packed:{mainFunc:function(n,o){return"\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        vec4 out4;\n        for (int i = 0; i < 4; i++) {\n            vec4 o = getValueFromTensorPosPacking_origin(oPos[0], oPos[1] * 4 + i, oPos[2], oPos[3]);\n            out4[i] = o[0];\n        }\n        setPackedOutput(out4);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPosPacking"]}},packed_2_unpacked:{mainFunc:function(n,o){return"\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float res = 0.0;\n        int c1 = calMod(oPos[1], 4);\n        vec4 o = getValueFromTensorPosPacking_origin(oPos[0], oPos[1] / 4, oPos[2], oPos[3]);\n\n        if (c1 == 0) {\n            res = o.r;\n        } else if (c1 == 1) {\n            res = o.g;\n        } else if (c1 == 2) {\n            res = o.b;\n        } else if (c1 == 3) {\n            res = o.a;\n        }\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPosPacking"]}},unsqueeze2:{mainFunc:function(n,o){var e=n.origin,t=o.axes,r=e.length_unformatted_shape,i=Array.isArray(t)?t:[t],s=4-r-i.length,a=i.map((function(n){return n+s})),u=[0,1,2,3].filter((function(n){return-1===a.indexOf(n)})).map((function(n){return"oPos["+n+"]"})),l=Array.from(new Array(a.length),(function(){return"0"}));return u.splice.apply(u,function(){for(var n=0,o=0,e=arguments.length;o<e;o++)n+=arguments[o].length;var t=Array(n),r=0;for(o=0;o<e;o++)for(var i=arguments[o],s=0,a=i.length;s<a;s++,r++)t[r]=i[s];return t}([0,0],l)),"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        o = getValueFromTensorPos_origin("+u.join(",")+");\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},flatten_contiguous_range:{mainFunc:function(n,o){var e=n.origin,t=n.out;return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a\n            + oPos.b * "+t.width_shape+"\n            + oPos.g * "+t.height_shape+" * "+t.width_shape+"\n            + oPos.r * "+t.channel+" * "+t.width_shape+" * "+t.height_shape+";\n        ivec4 new_oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+e.channel+",\n            "+e.width_shape+",\n            "+e.height_shape+",\n            "+e.total_shape+"\n        );\n        float o = getValueFromTensorPos_origin(new_oPos.r, new_oPos.g, new_oPos.b, new_oPos.a);\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]},flatten2:ln,greater_than:{mainFunc:function(n,o){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float x = getValueFromTensorPos_input(oPos.r, oPos.g, oPos.b, oPos.a);\n        float y = getValueFromTensorPos_counter(oPos.r, oPos.g, oPos.b, oPos.a);\n\n        setOutput(bool(x >= y));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]}},reduce_sum:{mainFunc:function(n,o){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        for (int i = 0; i < "+o.inputs_dim+"; i++) {\n            oPos["+o.dim+"] = i;\n            o += getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);;\n        }\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizeDim"]},where:{mainFunc:function(n,o){return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float x = getValueFromTensorPos_input(oPos.r, oPos.g, oPos.b, oPos.a);\n        float y = getValueFromTensorPos_counter(oPos.r, oPos.g, oPos.b, oPos.a);\n        float condition = getValueFromTensorPos_condition(oPos.r, oPos.g, oPos.b, oPos.a);\n        float o = 0.0;\n\n        if (bool(condition)) {\n            o = x;\n        }\n        else {\n            o = y;\n        }\n        setOutput(o);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"],condition:["getValueFromTensorPos"]}},connect:{mainFunc:function(n,o){var e=n.out,t=e.total_shape,r=e.width_shape,i=e.height_shape,s=e.channel,a=_([t/(r*i*s),s,i,r]),u=Object.keys(n).filter((function(n){return"out"!==n})).map((function(o){return n[o].total_shape})),l=u.map((function(n,o){return u.slice(0,o+1).reduce((function(n,o){return n+o}),0)})),f="";return l.forEach((function(n,o){f+=0===o?"\n            if (sumVal < "+n+") {\n                co = getTensorPosFromArrayIndex_origin(sumVal);\n                o = getValueFromTensorPos_origin(co.r, co.g, co.b, co.a);\n            }":"\n            else if (sumVal < "+n+") {\n                co = getTensorPosFromArrayIndex_origin_"+o+"(sumVal - "+l[o-1]+");\n                o = getValueFromTensorPos_origin_"+o+"(co.r, co.g, co.b, co.a);\n            }\n            "})),"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n        ivec4 co;\n        int sumVal = oPos.b * "+a[2]+" + oPos.a;\n        "+f+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{"@all":["getValueFromTensorPos","getTensorPosFromArrayIndex"]}},reduce_mean:{mainFunc:function(n,o){var e=o.inputs_dim;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n        for (int i = 0; i < "+e+"; i++) {\n            oPos["+o.dim+"] = i;\n            o += getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        }\n        o = o / float("+e+");\n        setOutput(o);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["normalizeDim"]},hard_swish:{mainFunc:function(n,o){var e=o.offset,t=void 0===e?3:e,r=o.scale,i=void 0===r?6:r,s=o.threshold;return"\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float res = o * min(max(0.0, o + float("+t+")), float("+(void 0===s?6:s)+")) / float("+i+");\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},nearest_interp:pn,nearest_interp_v2:pn,cast:{mainFunc:function(n,o){var e="";switch(o.out_dtype){case 0:e="\n            float res_bool = 0.0;\n            if (o != 0.0) {\n                res_bool = 1.0;\n            }\n            setOutput(res_bool);";break;case 1:case 2:case 3:e="\n            int res_int = int(o);\n            setOutput(float(res_int));";break;default:e="       \n            float res_float = o;\n            setOutput(res_float);"}return"\n    void main() {\n       // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        "+e+"\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},fill_constant_batch_size_like:{mainFunc:function(n,o){return"\n    // start函数\n    void main(void) {\n        float res = float("+o.value+");\n        setOutput(res);\n    }\n"}},rnn_matmul:{mainFunc:function(n,o){var e=n.weightlist_0,t=o.input_axis,r=o.state_axis,i=o.batch,s=o.reverse,a=void 0!==s&&s?i-t-1:t;return"\n    void main() {\n         float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        \n        if ("+(0===t)+") {\n            res = getValueFromTensorPos_origin(out_pos[0], "+a+", out_pos[2], out_pos[3]);\n            setOutput(res);\n            return;\n        }\n        \n        ivec4 origin_pos = out_pos;\n        ivec4 weight_pos = out_pos;\n\n        weight_pos[1] = 0;\n        weight_pos[2] = weight_pos[3];\n\n        float o = 0.0;\n        float w_hh = 0.0;\n        float prestate_h = 0.0;\n        res = getValueFromTensorPos_origin(out_pos[0], "+a+", out_pos[2], out_pos[3]);\n        for (int j = 0; j < "+e.width_shape+"; j++) {\n            prestate_h = getValueFromTensorPos_prestate(origin_pos[0], origin_pos[1], origin_pos[2], j);\n            w_hh = getValueFromTensorPos_weightlist_0(out_pos[0], "+r+", out_pos[3], j);\n            o += w_hh * prestate_h;\n        }\n        res += o;\n\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],prestate:["getValueFromTensorPos"],weightlist_0:["getValueFromTensorPos"]}},rnn_hidden:{mainFunc:function(n,o){var e=o.state_axis,t=o.hidden_size;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float origin = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float cell = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+t+");\n        float appender = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+2*t+");\n        float fourth = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+3*t+");\n        float counter  = getValueFromTensorPos_counter(oPos.r, "+e+", oPos.b, oPos.a);\n        float i = 1.0 / (1.0 + exp(-origin));\n        float f = 1.0 / (1.0 + exp(-cell));\n        float o = 1.0 / (1.0 + exp(-fourth));\n        float c = f * counter + i * tanh_calc(appender);\n        float h = o * tanh_calc(c);\n        \n        setOutput(h);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]}},rnn_cell:{mainFunc:function(n,o){var e=o.state_axis,t=o.hidden_size;return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float origin = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a);\n        float cell = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+t+");\n        float appender = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+2*t+");\n        float fourth = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b, oPos.a + "+3*t+");\n        float counter  = getValueFromTensorPos_counter(oPos.r, "+e+", oPos.b, oPos.a);\n        float i = 1.0 / (1.0 + exp(-origin));\n        float f = 1.0 / (1.0 + exp(-cell));\n        float c = f * counter + i * tanh_calc(appender);\n        \n        setOutput(c);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],counter:["getValueFromTensorPos"]}},rnn_origin:{mainFunc:function(n,o){var e=n.weightlist_0,t=n.weightlist_1,r=o.state_axis;return"\n    void main() {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        ivec4 origin_pos = out_pos;\n        ivec4 weight_pos = out_pos;\n      \n        weight_pos[1] = 0;\n        weight_pos[2] = weight_pos[3];\n\n        float b_ih = getValueFromTensorPos_weightlist_2(0, 0, 0, out_pos[3]);\n        float b_hh = getValueFromTensorPos_weightlist_3(0, 0, 0, out_pos[3]);\n        \n        for (int j = 0; j < "+e.width_shape+"; j++) {\n            float o = getValueFromTensorPos_origin(origin_pos[0], origin_pos[1], 0, j);\n            float w_ih = getValueFromTensorPos_weightlist_0(0, 0, out_pos[3], j);\n            res += w_ih * o;\n        }\n        res += b_ih;\n\n        for (int j = 0; j < "+t.width_shape+"; j++) {\n                float prestate = getValueFromTensorPos_prestate(0, 0, 0, j);\n                float w_hh = getValueFromTensorPos_weightlist_1(0, "+r+", out_pos[3], j);\n                res += w_hh * prestate;\n        }\n        res += b_hh;\n \n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"],prestate:["getValueFromTensorPos"],weightlist_0:["getValueFromTensorPos"],weightlist_1:["getValueFromTensorPos"],weightlist_2:["getValueFromTensorPos"],weightlist_3:["getValueFromTensorPos"]}},pool2d_avg:{mainFunc:function(n,o){var e=n.origin,t=o.strides,r=void 0===t?[]:t,i=o.paddings,s=void 0===i?[]:i,a=o.ksize,u=r[0],l=void 0===u?1:u,f=r[1],c=void 0===f?1:f,_=s[0],g=void 0===_?0:_,h=s[1],d=void 0===h?0:h,p=a[0],m=a[1];return"\n    // start函数\n    void main(void) {\n        float res = 0.0;\n        // 获取output的坐标\n        ivec4 out_pos = getOutputTensorPos();\n        // X、Y方向的移动步长\n        int oy_base = out_pos[2] * "+l+" - "+g+";\n        int ox_base = out_pos[3] * "+c+" - "+d+";\n        for (int fy = 0; fy < "+p+"; fy++) {\n            int oy = oy_base + fy;\n            if (oy >= "+e.height_shape+") {\n                break;\n            }\n            if (oy < 0) {\n                continue;\n            }\n            for (int fx = 0; fx < "+m+"; fx++) {\n                int ox = ox_base + fx;\n                if (ox >= "+e.width_shape+") {\n                    break;\n                }\n                if (ox < 0) {\n                    continue;\n                }\n                // origin数据\n                float curr = getValueFromTensorPos_origin(out_pos[0], out_pos[1], oy, ox);\n                res += curr;\n                // 在平均池化模式忽略填充值(exclusive默认为true）\n            }\n        }\n        res = res / float("+p+" * "+m+");\n        setOutput(res);\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},behaviors:["setPacked","setAdaptive","isGlobalPooling"]},prelu:hn("prelu"),relu6:hn("relu6"),leakyRelu:hn("leakyRelu"),scale:hn("scale"),sigmoid:hn("sigmoid"),relu:hn("relu"),hard_sigmoid:hn("hard_sigmoid"),pow:hn("pow"),sqrt:hn("sqrt"),tanh:hn("tanh"),squeeze2:dn,pad3d:{mainFunc:function(n,o){var e=n.origin,t=o.paddings,r=o.mode,i=o.value,s=function(n){var o=n.total_shape,e=n.channel,t=n.height_shape,r=n.width_shape;return[o/e/t/r,e,t,r]}(e),a={reflect:"\n            int a;\n            int b;\n            if (oPos.a - "+t[0]+" < 0) {\n                a = "+t[0]+" - oPos.a;\n            }\n            else if (oPos.a - "+t[0]+" >= "+s[3]+") {\n                a = "+s[3]+" - (oPos.a - "+t[0]+" - "+s[3]+" + 1) - 1;\n            }\n            else {\n                a = oPos.a - "+t[0]+";\n            }\n            if (oPos.b - "+t[2]+" < 0) {\n                b = "+t[2]+" - oPos.b;\n            }\n            else if (oPos.b - "+t[2]+" >= "+s[2]+") {\n                b = "+s[2]+" - (oPos.b - "+t[2]+" - "+s[2]+" + 1) - 1;\n            }\n            else {\n                b = oPos.b - "+t[2]+";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ",replicate:"\n            int a;\n            int b;\n            if (oPos.a - "+t[0]+" < 0) {\n                a = 0;\n            }\n            else if (oPos.a - "+t[0]+" >= "+s[3]+") {\n                a = "+s[3]+" - 1;\n            }\n            else {\n                a = oPos.a - "+t[0]+";\n            }\n            if (oPos.b - "+t[2]+" < 0) {\n                b = 0;\n            }\n            else if (oPos.b - "+t[2]+" >= "+s[2]+") {\n                b = "+s[2]+" - 1;\n            }\n            else {\n                b = oPos.b - "+t[2]+";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ",circular:"\n            int a;\n            int b;\n            if (oPos.a - "+t[0]+" < 0) {\n                a = int(mod(float("+t[0]+" + oPos.a - 1), float("+s[3]+")));\n            }\n            else if (oPos.a - "+t[0]+" >= "+s[3]+") {\n                a = int(mod(float(oPos.a - "+t[0]+" - "+s[3]+"), float("+s[3]+")));\n            }\n            else {\n                a = oPos.a - "+t[0]+";\n            }\n            if (oPos.b - "+t[2]+" < 0) {\n                b = int(mod(float("+t[2]+" + oPos.b - 1), float("+s[2]+")));\n            }\n            else if (oPos.b - "+t[2]+" >= "+s[2]+") {\n                b = int(mod(float(oPos.b - "+t[2]+" - "+s[2]+"), float("+s[2]+")));\n            }\n            else {\n                b = oPos.b - "+t[2]+";\n            }\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, b, a);\n        ",constant:"",undefined:""};return"\n    // start函数\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        float o = "+(i||"0.0")+";\n        if (oPos.a - "+t[0]+" >= 0\n            && oPos.b - "+t[2]+" >= 0\n            && oPos.a - "+t[0]+" < "+s[3]+"\n            && oPos.b - "+t[2]+" < "+s[2]+"\n        ) {\n            o = getValueFromTensorPos_origin(oPos.r, oPos.g, oPos.b - "+t[2]+", oPos.a - "+t[0]+");\n        }\n        else {\n            "+a[r]+"\n        }\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]}},bilinear_interp_v2:cn,shuffle_channel:{mainFunc:function(n,o){var e=n.out,t=o.group,r=void 0===t?2:t,i=e.total_shape,s=e.height_shape,a=e.width_shape,u=e.channel,l=[1,0,2,3];return"\n    // start函数\n    void main(void) {\n        // 输出数据\n        ivec4 oPos = getOutputTensorPos();\n        float o = 0.0;\n\n        int sumVal = oPos.a\n            + oPos.b * "+a+"\n            + oPos.g * "+s+" * "+a+"\n            + oPos.r * "+u+" * "+a+" * "+s+";\n\n        ivec4 transpose_out_pos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+r+",\n            "+a+",\n            "+s+",\n            "+i+"\n        );\n\n        ivec4 transpose_in_pos = ivec4(transpose_out_pos["+l[0]+"],\n            transpose_out_pos["+l[1]+"], transpose_out_pos["+l[2]+"], transpose_out_pos["+l[3]+"]);\n        int sumVal2 = transpose_in_pos.a\n            + transpose_in_pos.b * "+a+"\n            + transpose_in_pos.g * "+s+" * "+a+"\n            + transpose_in_pos.r * "+u/r+" * "+a+" * "+s+";\n        ivec4 origin_oPos = transferFromNHWCtoNCHW(\n            sumVal2,\n            "+u+",\n            "+a+",\n            "+s+",\n            "+i+"\n        );\n\n\n        o = getValueFromTensorPos_origin(\n            origin_oPos[0],\n            origin_oPos[1],\n            origin_oPos[2],\n            origin_oPos[3]\n        );\n\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]},pack_out:{mainFunc:function(n,o){return"\n\n    // start函数\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        vec2 outCoord = vCoord.xy * _2d_shape_texture_out;\n        int index = int(outCoord.x) + int(outCoord.y) * int("+n.out.width_texture+");\n\n        int first = index * 4;\n        int sec = index * 4 + 1;\n        int third = index * 4 + 2;\n        int fourth = index * 4 + 3;\n\n        ivec4 rPos = getTensorPosFromArrayIndex_origin(first);\n        ivec4 gPos = getTensorPosFromArrayIndex_origin(sec);\n        ivec4 bPos = getTensorPosFromArrayIndex_origin(third);\n        ivec4 aPos = getTensorPosFromArrayIndex_origin(fourth);\n\n        float r = getValueFromTensorPos_origin(rPos.r, rPos.g, rPos.b, rPos.a);\n        float g = getValueFromTensorPos_origin(gPos.r, gPos.g, gPos.b, gPos.a);\n        float b = getValueFromTensorPos_origin(bPos.r, bPos.g, bPos.b, bPos.a);\n        float a = getValueFromTensorPos_origin(aPos.r, aPos.g, aPos.b, aPos.a);\n\n        setPackedOutput(vec4(r, g, b, a));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos","getTensorPosFromArrayIndex"]}},nhwc_2_nchw:{mainFunc:function(n,o){var e=n.origin,t=n.out;return"\n    void main() {\n        ivec4 oPos = getOutputTensorPos();\n        // 输出坐标转换为输入坐标\n        int sumVal = oPos.a * "+t.channel+"\n            + oPos.b * "+t.width_shape+" * "+t.channel+"\n            + oPos.g\n            + oPos.r * "+t.channel+" * "+t.width_shape+" * "+t.height_shape+";\n        ivec4 new_oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+e.channel+",\n            "+e.width_shape+",\n            "+e.height_shape+",\n            "+e.total_shape+"\n        );\n        float o = getValueFromTensorPos_origin(new_oPos.r, new_oPos.g, new_oPos.b, new_oPos.a);\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPos"]},commonFuncConf:["transferFromNHWCtoNCHW"]},feedPost:{mainFunc:function(n,o){var e=n.out,t=o.mean,r=void 0===t?[0,0,0]:t,i=o.std,s=void 0===i?[1,1,1]:i,a=e.total_shape,u=e.height_shape,l=e.width_shape,f=e.channel;return"\n    // start函数\n    void main(void) {\n        ivec4 nhwcPos = getOutputTensorPos();\n        int sumVal = nhwcPos.a\n            + nhwcPos.b * "+l+"\n            + nhwcPos.g * "+u+" * "+l+"\n            + nhwcPos.r * "+f+" * "+l+" * "+u+";\n\n        ivec4 oPos = transferFromNHWCtoNCHW(\n            sumVal,\n            "+f+",\n            "+l+",\n            "+u+",\n            "+a+"\n        );\n        float res = 0.0;\n        int c1 = int(mod(float(oPos[1]), 4.0));\n        int c = oPos[1];\n        vec4 o = getValueFromTensorPosPacking_origin(oPos[0], c / 4, oPos[2], oPos[3]);\n\n        if (c1 == 0) {\n            res = o.r;\n        } else if (c1 == 1) {\n            res = o.g;\n        } else if (c1 == 2) {\n            res = o.b;\n        } else if (c1 == 3) {\n            res = o.a;\n        }\n\n        if (c == 0) {\n            res = (res - float("+r[0]+")) / float("+s[0]+");\n        } else if (c == 1) {\n            res = (res - float("+r[1]+")) / float("+s[1]+");\n        } else if (c == 2) {\n            res = (res - float("+r[2]+")) / float("+s[2]+");\n        }\n        setOutput(float(res));\n    }\n    "},textureFuncConf:{origin:["getValueFromTensorPosPacking"]},commonFuncConf:["transferFromNHWCtoNCHW"]},imgFeed:{mainFunc:function(){return"\n    uniform vec2 u_scale;\n    uniform float u_keep_ratio;\n\n    void main(void) {\n        vec2 outCoord = vCoord.xy;\n        // 支持模型不按比例拉伸\n        if (float(u_keep_ratio) == 0.0) {\n            vec4 origin = TEXTURE2D(texture_origin, outCoord);\n            setPackedOutput(origin);\n            return;\n        }\n        float startX = (1.0 - u_scale.x) / 2.0;\n        float endX = startX + u_scale.x;\n        float startY = (1.0 - u_scale.y) / 2.0;\n        float endY = startY + u_scale.y;\n\n        if (outCoord.x >= startX && outCoord.x <= endX && outCoord.y >= startY && outCoord.y <= endY) {\n            vec2 newPos = (outCoord - vec2(startX, startY)) / u_scale;\n            vec4 origin = TEXTURE2D(texture_origin, newPos);\n            setPackedOutput(origin);\n        }\n        else {\n            setPackedOutput(vec4(1.0, 1.0, 1.0, 1.0));\n        }\n    }\n    "},textureFuncConf:{origin:[]}},box_coder:{mainFunc:function(n,o){var e="decode_center_size"===o.code_type;return"\n    // start函数\n    vec2 getPriorBoxData(int r, int g, int b, int m, int n) {\n        float start = getValueFromTensorPos_priorbox(r, g, b, m);\n        float end = getValueFromTensorPos_priorbox(r, g, b, n);\n        float len = end - start;\n        return vec2(start + len / 2.0, len);\n    }\n    vec2 getBoxVarData(int r, int g, int b, int m, int n) {\n        return vec2(\n            getValueFromTensorPos_priorboxvar(r, g, b, m),\n            getValueFromTensorPos_priorboxvar(r, g, b, n)\n        );\n    }\n    vec2 getTargetBoxData(int r, int g, int b, int m, int n) {\n        "+(e?"\n            return vec2(\n                getValueFromTensorPos_targetbox(r, g, b, m),\n                getValueFromTensorPos_targetbox(r, g, b, n)\n            );\n        ":"\n            float start = getValueFromTensorPos_targetbox(r, g, b, m);\n            float end = getValueFromTensorPos_targetbox(r, g, b, n);\n            float len = end - start;\n            return vec2(start + len / 2.0, len);\n        ")+"\n    }\n\n    void main(void) {\n        ivec4 oPos = getOutputTensorPos();\n        int r = int(oPos.r);\n        int g = int(oPos.g);\n        int b = int(oPos.b);\n        int a = int(oPos.a);\n        // 输出坐标转换为输入坐标\n        float o = 0.0;\n\n        int m = 0;\n        int n = 0;\n        if (a == 0 || a == "+(e?2:1)+") {\n            m = 0;\n            n = 2;\n        }\n        else {\n            m = 1;\n            n = 3;\n        }\n        vec2 priorbox = getPriorBoxData(r, g, b, m, n);\n        vec2 boxvar = getBoxVarData(r, g, b, m, n);\n        vec2 targetbox = getTargetBoxData(r, g, b, m, n);\n        float p1 = priorbox.r;\n        float p2 = priorbox.g;\n        float t1 = targetbox.r;\n        float t2 = targetbox.g;\n        float v1 = boxvar.r;\n        float v2 = boxvar.g;\n\n        "+(e?"\n            float b1 = p2 * v1 * t1 + p1;\n            float b2 = exp(v2 * t2) * p2;\n            if (a == 0 || a == 1) {\n                o = b1 - b2 / 2.0 ;\n            }\n            else {\n                o = b1 + b2 / 2.0;\n            }\n        ":"\n            if (a == 0 || a == 1) {\n                o = (t1 - p1) / p2 / v1;\n            }\n            else {\n                o = log(abs(t2 / p2)) / v2;\n            }\n        ")+"\n        setOutput(float(o));\n    }\n    "},textureFuncConf:{targetbox:["getValueFromTensorPos"],priorbox:["getValueFromTensorPos"],priorboxvar:["getValueFromTensorPos"]},behaviors:[]},density_prior_box:Pn,prior_box:vn},Tn=new Q;!function(n,o,e){n&&(u.backend=n),o&&(u.backendInstance=o),e&&Object.keys(e).forEach((function(n){!function(n,o){var e=n.conf,t=n.params,r=n.main,i=n.mainFunc,s=n.textureFuncConf,a=n.commonFuncConf,l=n.behaviors,f=void 0===l?[]:l,c=u.backend+"_"+o;u.opRegistry.ops[c]||(u.opRegistry.ops[c]={name:o,conf:e,params:t,main:r,mainFunc:i,textureFuncConf:s,commonFuncConf:a,behaviors:f})}(e[n],n)}))}("webgl",Tn,xn)}},o={};function e(t){if(o[t])return o[t].exports;var r=o[t]={exports:{}};return n[t](r,r.exports,e),r.exports}return e.d=(n,o)=>{for(var t in o)e.o(o,t)&&!e.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:o[t]})},e.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(n){if("object"==typeof window)return window}}(),e.o=(n,o)=>Object.prototype.hasOwnProperty.call(n,o),e.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},e(646)})()}));
}, function(modId) {var map = {}; return __REQUIRE__(map[modId], modId); })
return __REQUIRE__(1649414428465);
})()
//miniprogram-npm-outsideDeps=[]
//# sourceMappingURL=index.js.map